
(function(r,f) {
    var a=f();
    if(typeof a!=='object')return;
    var e=[typeof module==='object'&&typeof module.exports==='object'?module.exports:null,typeof window!=='undefined'?window:null,r&&r!==window?r:null];
    for(var i in a){e[0]&&(e[0][i]=a[i]);e[1]&&i!=='__esModule'&&(e[1][i] = a[i]);e[2]&&(e[2][i]=a[i]);}
})(this,function(){
    return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./libs/mapael/mapael.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./libs/mapael/mapael.js":
/*!*******************************!*\
  !*** ./libs/mapael/mapael.js ***!
  \*******************************/
/*! exports provided: Mapael */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_jquery_mapael_js_jquery_mapael_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/jquery-mapael/js/jquery.mapael.js */ \"./node_modules/jquery-mapael/js/jquery.mapael.js\");\n/* harmony import */ var _node_modules_jquery_mapael_js_jquery_mapael_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_jquery_mapael_js_jquery_mapael_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"Mapael\", function() { return _node_modules_jquery_mapael_js_jquery_mapael_js__WEBPACK_IMPORTED_MODULE_0__; });\n\n\n\n\n\n//# sourceURL=webpack:///./libs/mapael/mapael.js?");

/***/ }),

/***/ "./node_modules/jquery-mapael/js/jquery.mapael.js":
/*!********************************************************!*\
  !*** ./node_modules/jquery-mapael/js/jquery.mapael.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n *\n * Jquery Mapael - Dynamic maps jQuery plugin (based on raphael.js)\n * Requires jQuery, raphael.js and jquery.mousewheel\n *\n * Version: 2.2.0\n *\n * Copyright (c) 2017 Vincent Brout√© (https://www.vincentbroute.fr/mapael)\n * Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php).\n *\n * Thanks to Indigo744\n *\n */\n(function (factory) {\n    if (true) {\n        // CommonJS\n        module.exports = factory(__webpack_require__(/*! jquery */ \"jquery\"), __webpack_require__(/*! raphael */ \"raphael\"), __webpack_require__(/*! jquery-mousewheel */ \"./node_modules/jquery-mousewheel/jquery.mousewheel.js\"));\n    } else {}\n}(function ($, Raphael, mousewheel, undefined) {\n\n    \"use strict\";\n\n    // The plugin name (used on several places)\n    var pluginName = \"mapael\";\n\n    // Version number of jQuery Mapael. See http://semver.org/ for more information.\n    var version = \"2.2.0\";\n\n    /*\n     * Mapael constructor\n     * Init instance vars and call init()\n     * @param container the DOM element on which to apply the plugin\n     * @param options the complete options to use\n     */\n    var Mapael = function (container, options) {\n        var self = this;\n\n        // the global container (DOM element object)\n        self.container = container;\n\n        // the global container (jQuery object)\n        self.$container = $(container);\n\n        // the global options\n        self.options = self.extendDefaultOptions(options);\n\n        // zoom TimeOut handler (used to set and clear)\n        self.zoomTO = 0;\n\n        // zoom center coordinate (set at touchstart)\n        self.zoomCenterX = 0;\n        self.zoomCenterY = 0;\n\n        // Zoom pinch (set at touchstart and touchmove)\n        self.previousPinchDist = 0;\n\n        // Zoom data\n        self.zoomData = {\n            zoomLevel: 0,\n            zoomX: 0,\n            zoomY: 0,\n            panX: 0,\n            panY: 0\n        };\n\n        self.currentViewBox = {\n            x: 0, y: 0, w: 0, h: 0\n        };\n\n        // Panning: tell if panning action is in progress\n        self.panning = false;\n\n        // Animate view box\n        self.zoomAnimID = null; // Interval handler (used to set and clear)\n        self.zoomAnimStartTime = null; // Animation start time\n        self.zoomAnimCVBTarget = null; // Current ViewBox target\n\n        // Map subcontainer jQuery object\n        self.$map = $(\".\" + self.options.map.cssClass, self.container);\n\n        // Save initial HTML content (used by destroy method)\n        self.initialMapHTMLContent = self.$map.html();\n\n        // The tooltip jQuery object\n        self.$tooltip = {};\n\n        // The paper Raphael object\n        self.paper = {};\n\n        // The areas object list\n        self.areas = {};\n\n        // The plots object list\n        self.plots = {};\n\n        // The links object list\n        self.links = {};\n\n        // The legends list\n        self.legends = {};\n\n        // The map configuration object (taken from map file)\n        self.mapConf = {};\n\n        // Holds all custom event handlers\n        self.customEventHandlers = {};\n\n        // Let's start the initialization\n        self.init();\n    };\n\n    /*\n     * Mapael Prototype\n     * Defines all methods and properties needed by Mapael\n     * Each mapael object inherits their properties and methods from this prototype\n     */\n    Mapael.prototype = {\n\n        /* Filtering TimeOut value in ms\n         * Used for mouseover trigger over elements */\n        MouseOverFilteringTO: 120,\n        /* Filtering TimeOut value in ms\n         * Used for afterPanning trigger when panning */\n        panningFilteringTO: 150,\n        /* Filtering TimeOut value in ms\n         * Used for mouseup/touchend trigger when panning */\n        panningEndFilteringTO: 50,\n        /* Filtering TimeOut value in ms\n         * Used for afterZoom trigger when zooming */\n        zoomFilteringTO: 150,\n        /* Filtering TimeOut value in ms\n         * Used for when resizing window */\n        resizeFilteringTO: 150,\n\n        /*\n         * Initialize the plugin\n         * Called by the constructor\n         */\n        init: function () {\n            var self = this;\n\n            // Init check for class existence\n            if (self.options.map.cssClass === \"\" || $(\".\" + self.options.map.cssClass, self.container).length === 0) {\n                throw new Error(\"The map class `\" + self.options.map.cssClass + \"` doesn't exists\");\n            }\n\n            // Create the tooltip container\n            self.$tooltip = $(\"<div>\").addClass(self.options.map.tooltip.cssClass).css(\"display\", \"none\");\n\n            // Get the map container, empty it then append tooltip\n            self.$map.empty().append(self.$tooltip);\n\n            // Get the map from $.mapael or $.fn.mapael (backward compatibility)\n            if ($[pluginName] && $[pluginName].maps && $[pluginName].maps[self.options.map.name]) {\n                // Mapael version >= 2.x\n                self.mapConf = $[pluginName].maps[self.options.map.name];\n            } else if ($.fn[pluginName] && $.fn[pluginName].maps && $.fn[pluginName].maps[self.options.map.name]) {\n                // Mapael version <= 1.x - DEPRECATED\n                self.mapConf = $.fn[pluginName].maps[self.options.map.name];\n                if (window.console && window.console.warn) {\n                    window.console.warn(\"Extending $.fn.mapael is deprecated (map '\" + self.options.map.name + \"')\");\n                }\n            } else {\n                throw new Error(\"Unknown map '\" + self.options.map.name + \"'\");\n            }\n\n            // Create Raphael paper\n            self.paper = new Raphael(self.$map[0], self.mapConf.width, self.mapConf.height);\n\n            // issue #135: Check for Raphael bug on text element boundaries\n            if (self.isRaphaelBBoxBugPresent() === true) {\n                self.destroy();\n                throw new Error(\"Can't get boundary box for text (is your container hidden? See #135)\");\n            }\n\n            // add plugin class name on element\n            self.$container.addClass(pluginName);\n\n            if (self.options.map.tooltip.css) self.$tooltip.css(self.options.map.tooltip.css);\n            self.setViewBox(0, 0, self.mapConf.width, self.mapConf.height);\n\n            // Handle map size\n            if (self.options.map.width) {\n                // NOT responsive: map has a fixed width\n                self.paper.setSize(self.options.map.width, self.mapConf.height * (self.options.map.width / self.mapConf.width));\n            } else {\n                // Responsive: handle resizing of the map\n                self.initResponsiveSize();\n            }\n\n            // Draw map areas\n            $.each(self.mapConf.elems, function (id) {\n                // Init area object\n                self.areas[id] = {};\n                // Set area options\n                self.areas[id].options = self.getElemOptions(\n                    self.options.map.defaultArea,\n                    (self.options.areas[id] ? self.options.areas[id] : {}),\n                    self.options.legend.area\n                );\n                // draw area\n                self.areas[id].mapElem = self.paper.path(self.mapConf.elems[id]);\n            });\n\n            // Hook that allows to add custom processing on the map\n            if (self.options.map.beforeInit) self.options.map.beforeInit(self.$container, self.paper, self.options);\n\n            // Init map areas in a second loop\n            // Allows text to be added after ALL areas and prevent them from being hidden\n            $.each(self.mapConf.elems, function (id) {\n                self.initElem(id, 'area', self.areas[id]);\n            });\n\n            // Draw links\n            self.links = self.drawLinksCollection(self.options.links);\n\n            // Draw plots\n            $.each(self.options.plots, function (id) {\n                self.plots[id] = self.drawPlot(id);\n            });\n\n            // Attach zoom event\n            self.$container.on(\"zoom.\" + pluginName, function (e, zoomOptions) {\n                self.onZoomEvent(e, zoomOptions);\n            });\n\n            if (self.options.map.zoom.enabled) {\n                // Enable zoom\n                self.initZoom(self.mapConf.width, self.mapConf.height, self.options.map.zoom);\n            }\n\n            // Set initial zoom\n            if (self.options.map.zoom.init !== undefined) {\n                if (self.options.map.zoom.init.animDuration === undefined) {\n                    self.options.map.zoom.init.animDuration = 0;\n                }\n                self.$container.trigger(\"zoom\", self.options.map.zoom.init);\n            }\n\n            // Create the legends for areas\n            self.createLegends(\"area\", self.areas, 1);\n\n            // Create the legends for plots taking into account the scale of the map\n            self.createLegends(\"plot\", self.plots, self.paper.width / self.mapConf.width);\n\n            // Attach update event\n            self.$container.on(\"update.\" + pluginName, function (e, opt) {\n                self.onUpdateEvent(e, opt);\n            });\n\n            // Attach showElementsInRange event\n            self.$container.on(\"showElementsInRange.\" + pluginName, function (e, opt) {\n                self.onShowElementsInRange(e, opt);\n            });\n\n            // Attach delegated events\n            self.initDelegatedMapEvents();\n            // Attach delegated custom events\n            self.initDelegatedCustomEvents();\n\n            // Hook that allows to add custom processing on the map\n            if (self.options.map.afterInit) self.options.map.afterInit(self.$container, self.paper, self.areas, self.plots, self.options);\n\n            $(self.paper.desc).append(\" and Mapael \" + self.version + \" (https://www.vincentbroute.fr/mapael/)\");\n        },\n\n        /*\n         * Destroy mapael\n         * This function effectively detach mapael from the container\n         *   - Set the container back to the way it was before mapael instanciation\n         *   - Remove all data associated to it (memory can then be free'ed by browser)\n         *\n         * This method can be call directly by user:\n         *     $(\".mapcontainer\").data(\"mapael\").destroy();\n         *\n         * This method is also automatically called if the user try to call mapael\n         * on a container already containing a mapael instance\n         */\n        destroy: function () {\n            var self = this;\n\n            // Detach all event listeners attached to the container\n            self.$container.off(\".\" + pluginName);\n            self.$map.off(\".\" + pluginName);\n\n            // Detach the global resize event handler\n            if (self.onResizeEvent) $(window).off(\"resize.\" + pluginName, self.onResizeEvent);\n\n            // Empty the container (this will also detach all event listeners)\n            self.$map.empty();\n\n            // Replace initial HTML content\n            self.$map.html(self.initialMapHTMLContent);\n\n            // Empty legend containers and replace initial HTML content\n            $.each(self.legends, function(legendType) {\n                $.each(self.legends[legendType], function(legendIndex) {\n                    var legend = self.legends[legendType][legendIndex];\n                    legend.container.empty();\n                    legend.container.html(legend.initialHTMLContent);\n                });\n            });\n\n            // Remove mapael class\n            self.$container.removeClass(pluginName);\n\n            // Remove the data\n            self.$container.removeData(pluginName);\n\n            // Remove all internal reference\n            self.container = undefined;\n            self.$container = undefined;\n            self.options = undefined;\n            self.paper = undefined;\n            self.$map = undefined;\n            self.$tooltip = undefined;\n            self.mapConf = undefined;\n            self.areas = undefined;\n            self.plots = undefined;\n            self.links = undefined;\n            self.customEventHandlers = undefined;\n        },\n\n        initResponsiveSize: function () {\n            var self = this;\n            var resizeTO = null;\n\n            // Function that actually handle the resizing\n            var handleResize = function(isInit) {\n                var containerWidth = self.$map.width();\n\n                if (self.paper.width !== containerWidth) {\n                    var newScale = containerWidth / self.mapConf.width;\n                    // Set new size\n                    self.paper.setSize(containerWidth, self.mapConf.height * newScale);\n\n                    // Create plots legend again to take into account the new scale\n                    // Do not do this on init (it will be done later)\n                    if (isInit !== true && self.options.legend.redrawOnResize) {\n                        self.createLegends(\"plot\", self.plots, newScale);\n                    }\n                }\n            };\n\n            self.onResizeEvent = function() {\n                // Clear any previous setTimeout (avoid too much triggering)\n                clearTimeout(resizeTO);\n                // setTimeout to wait for the user to finish its resizing\n                resizeTO = setTimeout(function () {\n                    handleResize();\n                }, self.resizeFilteringTO);\n            };\n\n            // Attach resize handler\n            $(window).on(\"resize.\" + pluginName, self.onResizeEvent);\n\n            // Call once\n            handleResize(true);\n        },\n\n        /*\n         * Extend the user option with the default one\n         * @param options the user options\n         * @return new options object\n         */\n        extendDefaultOptions: function (options) {\n\n            // Extend default options with user options\n            options = $.extend(true, {}, Mapael.prototype.defaultOptions, options);\n\n            // Extend legend default options\n            $.each(['area', 'plot'], function (key, type) {\n                if ($.isArray(options.legend[type])) {\n                    for (var i = 0; i < options.legend[type].length; ++i)\n                        options.legend[type][i] = $.extend(true, {}, Mapael.prototype.legendDefaultOptions[type], options.legend[type][i]);\n                } else {\n                    options.legend[type] = $.extend(true, {}, Mapael.prototype.legendDefaultOptions[type], options.legend[type]);\n                }\n            });\n\n            return options;\n        },\n\n        /*\n         * Init all delegated events for the whole map:\n         *  mouseover\n         *  mousemove\n         *  mouseout\n         */\n        initDelegatedMapEvents: function() {\n            var self = this;\n\n            // Mapping between data-type value and the corresponding elements array\n            // Note: legend-elem and legend-label are not in this table because\n            //       they need a special processing\n            var dataTypeToElementMapping = {\n                'area'  : self.areas,\n                'area-text' : self.areas,\n                'plot' : self.plots,\n                'plot-text' : self.plots,\n                'link' : self.links,\n                'link-text' : self.links\n            };\n\n            /* Attach mouseover event delegation\n             * Note: we filter the event with a timeout to reduce the firing when the mouse moves quickly\n             */\n            var mapMouseOverTimeoutID;\n            self.$container.on(\"mouseover.\" + pluginName, \"[data-id]\", function () {\n                var elem = this;\n                clearTimeout(mapMouseOverTimeoutID);\n                mapMouseOverTimeoutID = setTimeout(function() {\n                    var $elem = $(elem);\n                    var id = $elem.attr('data-id');\n                    var type = $elem.attr('data-type');\n\n                    if (dataTypeToElementMapping[type] !== undefined) {\n                        self.elemEnter(dataTypeToElementMapping[type][id]);\n                    } else if (type === 'legend-elem' || type === 'legend-label') {\n                        var legendIndex = $elem.attr('data-legend-id');\n                        var legendType = $elem.attr('data-legend-type');\n                        self.elemEnter(self.legends[legendType][legendIndex].elems[id]);\n                    }\n                }, self.MouseOverFilteringTO);\n            });\n\n            /* Attach mousemove event delegation\n             * Note: timeout filtering is small to update the Tooltip position fast\n             */\n            var mapMouseMoveTimeoutID;\n            self.$container.on(\"mousemove.\" + pluginName, \"[data-id]\", function (event) {\n                var elem = this;\n                clearTimeout(mapMouseMoveTimeoutID);\n                mapMouseMoveTimeoutID = setTimeout(function() {\n                    var $elem = $(elem);\n                    var id = $elem.attr('data-id');\n                    var type = $elem.attr('data-type');\n\n                    if (dataTypeToElementMapping[type] !== undefined) {\n                        self.elemHover(dataTypeToElementMapping[type][id], event);\n                    } else if (type === 'legend-elem' || type === 'legend-label') {\n                        /* Nothing to do */\n                    }\n\n                }, 0);\n            });\n\n            /* Attach mouseout event delegation\n             * Note: we don't perform any timeout filtering to clear & reset elem ASAP\n             * Otherwise an element may be stuck in 'hover' state (which is NOT good)\n             */\n            self.$container.on(\"mouseout.\" + pluginName, \"[data-id]\", function () {\n                var elem = this;\n                // Clear any\n                clearTimeout(mapMouseOverTimeoutID);\n                clearTimeout(mapMouseMoveTimeoutID);\n                var $elem = $(elem);\n                var id = $elem.attr('data-id');\n                var type = $elem.attr('data-type');\n\n                if (dataTypeToElementMapping[type] !== undefined) {\n                    self.elemOut(dataTypeToElementMapping[type][id]);\n                } else if (type === 'legend-elem' || type === 'legend-label') {\n                    var legendIndex = $elem.attr('data-legend-id');\n                    var legendType = $elem.attr('data-legend-type');\n                    self.elemOut(self.legends[legendType][legendIndex].elems[id]);\n                }\n            });\n\n            /* Attach click event delegation\n             * Note: we filter the event with a timeout to avoid double click\n             */\n            self.$container.on(\"click.\" + pluginName, \"[data-id]\", function (evt, opts) {\n                var $elem = $(this);\n                var id = $elem.attr('data-id');\n                var type = $elem.attr('data-type');\n\n                if (dataTypeToElementMapping[type] !== undefined) {\n                    self.elemClick(dataTypeToElementMapping[type][id]);\n                } else if (type === 'legend-elem' || type === 'legend-label') {\n                    var legendIndex = $elem.attr('data-legend-id');\n                    var legendType = $elem.attr('data-legend-type');\n                    self.handleClickOnLegendElem(self.legends[legendType][legendIndex].elems[id], id, legendIndex, legendType, opts);\n                }\n            });\n        },\n\n        /*\n         * Init all delegated custom events\n         */\n        initDelegatedCustomEvents: function() {\n            var self = this;\n\n            $.each(self.customEventHandlers, function(eventName) {\n                // Namespace the custom event\n                // This allow to easily unbound only custom events and not regular ones\n                var fullEventName = eventName + '.' + pluginName + \".custom\";\n                self.$container.off(fullEventName).on(fullEventName, \"[data-id]\", function (e) {\n                    var $elem = $(this);\n                    var id = $elem.attr('data-id');\n                    var type = $elem.attr('data-type').replace('-text', '');\n\n                    if (!self.panning &&\n                        self.customEventHandlers[eventName][type] !== undefined &&\n                        self.customEventHandlers[eventName][type][id] !== undefined)\n                    {\n                        // Get back related elem\n                        var elem = self.customEventHandlers[eventName][type][id];\n                        // Run callback provided by user\n                        elem.options.eventHandlers[eventName](e, id, elem.mapElem, elem.textElem, elem.options);\n                    }\n                });\n            });\n\n        },\n\n        /*\n         * Init the element \"elem\" on the map (drawing text, setting attributes, events, tooltip, ...)\n         *\n         * @param id the id of the element\n         * @param type the type of the element (area, plot, link)\n         * @param elem object the element object (with mapElem), it will be updated\n         */\n        initElem: function (id, type, elem) {\n            var self = this;\n            var $mapElem = $(elem.mapElem.node);\n\n            // If an HTML link exists for this element, add cursor attributes\n            if (elem.options.href) {\n                elem.options.attrs.cursor = \"pointer\";\n                if (elem.options.text) elem.options.text.attrs.cursor = \"pointer\";\n            }\n\n            // Set SVG attributes to map element\n            elem.mapElem.attr(elem.options.attrs);\n            // Set DOM attributes to map element\n            $mapElem.attr({\n                \"data-id\": id,\n                \"data-type\": type\n            });\n            if (elem.options.cssClass !== undefined) {\n                $mapElem.addClass(elem.options.cssClass);\n            }\n\n            // Init the label related to the element\n            if (elem.options.text && elem.options.text.content !== undefined) {\n                // Set a text label in the area\n                var textPosition = self.getTextPosition(elem.mapElem.getBBox(), elem.options.text.position, elem.options.text.margin);\n                elem.options.text.attrs.text = elem.options.text.content;\n                elem.options.text.attrs.x = textPosition.x;\n                elem.options.text.attrs.y = textPosition.y;\n                elem.options.text.attrs['text-anchor'] = textPosition.textAnchor;\n                // Draw text\n                elem.textElem = self.paper.text(textPosition.x, textPosition.y, elem.options.text.content);\n                // Apply SVG attributes to text element\n                elem.textElem.attr(elem.options.text.attrs);\n                // Apply DOM attributes\n                $(elem.textElem.node).attr({\n                    \"data-id\": id,\n                    \"data-type\": type + '-text'\n                });\n            }\n\n            // Set user event handlers\n            if (elem.options.eventHandlers) self.setEventHandlers(id, type, elem);\n\n            // Set hover option for mapElem\n            self.setHoverOptions(elem.mapElem, elem.options.attrs, elem.options.attrsHover);\n\n            // Set hover option for textElem\n            if (elem.textElem) self.setHoverOptions(elem.textElem, elem.options.text.attrs, elem.options.text.attrsHover);\n        },\n\n        /*\n         * Init zoom and panning for the map\n         * @param mapWidth\n         * @param mapHeight\n         * @param zoomOptions\n         */\n        initZoom: function (mapWidth, mapHeight, zoomOptions) {\n            var self = this;\n            var mousedown = false;\n            var previousX = 0;\n            var previousY = 0;\n            var fnZoomButtons = {\n                \"reset\": function () {\n                    self.$container.trigger(\"zoom\", {\"level\": 0});\n                },\n                \"in\": function () {\n                    self.$container.trigger(\"zoom\", {\"level\": \"+1\"});\n                },\n                \"out\": function () {\n                    self.$container.trigger(\"zoom\", {\"level\": -1});\n                }\n            };\n\n            // init Zoom data\n            $.extend(self.zoomData, {\n                zoomLevel: 0,\n                panX: 0,\n                panY: 0\n            });\n\n            // init zoom buttons\n            $.each(zoomOptions.buttons, function(type, opt) {\n                if (fnZoomButtons[type] === undefined) throw new Error(\"Unknown zoom button '\" + type + \"'\");\n                // Create div with classes, contents and title (for tooltip)\n                var $button = $(\"<div>\").addClass(opt.cssClass)\n                    .html(opt.content)\n                    .attr(\"title\", opt.title);\n                // Assign click event\n                $button.on(\"click.\" + pluginName, fnZoomButtons[type]);\n                // Append to map\n                self.$map.append($button);\n            });\n\n            // Update the zoom level of the map on mousewheel\n            if (self.options.map.zoom.mousewheel) {\n                self.$map.on(\"mousewheel.\" + pluginName, function (e) {\n                    var zoomLevel = (e.deltaY > 0) ? 1 : -1;\n                    var coord = self.mapPagePositionToXY(e.pageX, e.pageY);\n\n                    self.$container.trigger(\"zoom\", {\n                        \"fixedCenter\": true,\n                        \"level\": self.zoomData.zoomLevel + zoomLevel,\n                        \"x\": coord.x,\n                        \"y\": coord.y\n                    });\n\n                    e.preventDefault();\n                });\n            }\n\n            // Update the zoom level of the map on touch pinch\n            if (self.options.map.zoom.touch) {\n                self.$map.on(\"touchstart.\" + pluginName, function (e) {\n                    if (e.originalEvent.touches.length === 2) {\n                        self.zoomCenterX = (e.originalEvent.touches[0].pageX + e.originalEvent.touches[1].pageX) / 2;\n                        self.zoomCenterY = (e.originalEvent.touches[0].pageY + e.originalEvent.touches[1].pageY) / 2;\n                        self.previousPinchDist = Math.sqrt(Math.pow((e.originalEvent.touches[1].pageX - e.originalEvent.touches[0].pageX), 2) + Math.pow((e.originalEvent.touches[1].pageY - e.originalEvent.touches[0].pageY), 2));\n                    }\n                });\n\n                self.$map.on(\"touchmove.\" + pluginName, function (e) {\n                    var pinchDist = 0;\n                    var zoomLevel = 0;\n\n                    if (e.originalEvent.touches.length === 2) {\n                        pinchDist = Math.sqrt(Math.pow((e.originalEvent.touches[1].pageX - e.originalEvent.touches[0].pageX), 2) + Math.pow((e.originalEvent.touches[1].pageY - e.originalEvent.touches[0].pageY), 2));\n\n                        if (Math.abs(pinchDist - self.previousPinchDist) > 15) {\n                            var coord = self.mapPagePositionToXY(self.zoomCenterX, self.zoomCenterY);\n                            zoomLevel = (pinchDist - self.previousPinchDist) / Math.abs(pinchDist - self.previousPinchDist);\n                            self.$container.trigger(\"zoom\", {\n                                \"fixedCenter\": true,\n                                \"level\": self.zoomData.zoomLevel + zoomLevel,\n                                \"x\": coord.x,\n                                \"y\": coord.y\n                            });\n                            self.previousPinchDist = pinchDist;\n                        }\n                        return false;\n                    }\n                });\n            }\n\n            // When the user drag the map, prevent to move the clicked element instead of dragging the map (behaviour seen with Firefox)\n            self.$map.on(\"dragstart\", function() {\n                return false;\n            });\n\n            // Panning\n            var panningMouseUpTO = null;\n            var panningMouseMoveTO = null;\n            $(\"body\").on(\"mouseup.\" + pluginName + (zoomOptions.touch ? \" touchend.\" + pluginName : \"\"), function () {\n                mousedown = false;\n                clearTimeout(panningMouseUpTO);\n                clearTimeout(panningMouseMoveTO);\n                panningMouseUpTO = setTimeout(function () {\n                    self.panning = false;\n                }, self.panningEndFilteringTO);\n            });\n\n            self.$map.on(\"mousedown.\" + pluginName + (zoomOptions.touch ? \" touchstart.\" + pluginName : \"\"), function (e) {\n                clearTimeout(panningMouseUpTO);\n                clearTimeout(panningMouseMoveTO);\n                if (e.pageX !== undefined) {\n                    mousedown = true;\n                    previousX = e.pageX;\n                    previousY = e.pageY;\n                } else {\n                    if (e.originalEvent.touches.length === 1) {\n                        mousedown = true;\n                        previousX = e.originalEvent.touches[0].pageX;\n                        previousY = e.originalEvent.touches[0].pageY;\n                    }\n                }\n            }).on(\"mousemove.\" + pluginName + (zoomOptions.touch ? \" touchmove.\" + pluginName : \"\"), function (e) {\n                var currentLevel = self.zoomData.zoomLevel;\n                var pageX = 0;\n                var pageY = 0;\n\n                clearTimeout(panningMouseUpTO);\n                clearTimeout(panningMouseMoveTO);\n\n                if (e.pageX !== undefined) {\n                    pageX = e.pageX;\n                    pageY = e.pageY;\n                } else {\n                    if (e.originalEvent.touches.length === 1) {\n                        pageX = e.originalEvent.touches[0].pageX;\n                        pageY = e.originalEvent.touches[0].pageY;\n                    } else {\n                        mousedown = false;\n                    }\n                }\n\n                if (mousedown && currentLevel !== 0) {\n                    var offsetX = (previousX - pageX) / (1 + (currentLevel * zoomOptions.step)) * (mapWidth / self.paper.width);\n                    var offsetY = (previousY - pageY) / (1 + (currentLevel * zoomOptions.step)) * (mapHeight / self.paper.height);\n                    var panX = Math.min(Math.max(0, self.currentViewBox.x + offsetX), (mapWidth - self.currentViewBox.w));\n                    var panY = Math.min(Math.max(0, self.currentViewBox.y + offsetY), (mapHeight - self.currentViewBox.h));\n\n                    if (Math.abs(offsetX) > 5 || Math.abs(offsetY) > 5) {\n                        $.extend(self.zoomData, {\n                            panX: panX,\n                            panY: panY,\n                            zoomX: panX + self.currentViewBox.w / 2,\n                            zoomY: panY + self.currentViewBox.h / 2\n                        });\n                        self.setViewBox(panX, panY, self.currentViewBox.w, self.currentViewBox.h);\n\n                        panningMouseMoveTO = setTimeout(function () {\n                            self.$map.trigger(\"afterPanning\", {\n                                x1: panX,\n                                y1: panY,\n                                x2: (panX + self.currentViewBox.w),\n                                y2: (panY + self.currentViewBox.h)\n                            });\n                        }, self.panningFilteringTO);\n\n                        previousX = pageX;\n                        previousY = pageY;\n                        self.panning = true;\n                    }\n                    return false;\n                }\n            });\n        },\n\n        /*\n         * Map a mouse position to a map position\n         *      Transformation principle:\n         *          ** start with (pageX, pageY) absolute mouse coordinate\n         *          - Apply translation: take into accounts the map offset in the page\n         *          ** from this point, we have relative mouse coordinate\n         *          - Apply homothetic transformation: take into accounts initial factor of map sizing (fullWidth / actualWidth)\n         *          - Apply homothetic transformation: take into accounts the zoom factor\n         *          ** from this point, we have relative map coordinate\n         *          - Apply translation: take into accounts the current panning of the map\n         *          ** from this point, we have absolute map coordinate\n         * @param pageX: mouse client coordinate on X\n         * @param pageY: mouse client coordinate on Y\n         * @return map coordinate {x, y}\n         */\n        mapPagePositionToXY: function(pageX, pageY) {\n            var self = this;\n            var offset = self.$map.offset();\n            var initFactor = (self.options.map.width) ? (self.mapConf.width / self.options.map.width) : (self.mapConf.width / self.$map.width());\n            var zoomFactor = 1 / (1 + (self.zoomData.zoomLevel * self.options.map.zoom.step));\n            return {\n                x: (zoomFactor * initFactor * (pageX - offset.left)) + self.zoomData.panX,\n                y: (zoomFactor * initFactor * (pageY - offset.top)) + self.zoomData.panY\n            };\n        },\n\n        /*\n         * Zoom on the map\n         *\n         * zoomOptions.animDuration zoom duration\n         *\n         * zoomOptions.level        level of the zoom between minLevel and maxLevel (absolute number, or relative string +1 or -1)\n         * zoomOptions.fixedCenter  set to true in order to preserve the position of x,y in the canvas when zoomed\n         *\n         * zoomOptions.x            x coordinate of the point to focus on\n         * zoomOptions.y            y coordinate of the point to focus on\n         * - OR -\n         * zoomOptions.latitude     latitude of the point to focus on\n         * zoomOptions.longitude    longitude of the point to focus on\n         * - OR -\n         * zoomOptions.plot         plot ID to focus on\n         * - OR -\n         * zoomOptions.area         area ID to focus on\n         * zoomOptions.areaMargin   margin (in pixels) around the area\n         *\n         * If an area ID is specified, the algorithm will override the zoom level to focus on the area\n         * but it may be limited by the min/max zoom level limits set at initialization.\n         *\n         * If no coordinates are specified, the zoom will be focused on the center of the current view box\n         *\n         */\n        onZoomEvent: function (e, zoomOptions) {\n            var self = this;\n\n            // new Top/Left corner coordinates\n            var panX;\n            var panY;\n            // new Width/Height viewbox size\n            var panWidth;\n            var panHeight;\n\n            // Zoom level in absolute scale (from 0 to max, by step of 1)\n            var zoomLevel = self.zoomData.zoomLevel;\n\n            // Relative zoom level (from 1 to max, by step of 0.25 (default))\n            var previousRelativeZoomLevel = 1 + self.zoomData.zoomLevel * self.options.map.zoom.step;\n            var relativeZoomLevel;\n\n            var animDuration = (zoomOptions.animDuration !== undefined) ? zoomOptions.animDuration : self.options.map.zoom.animDuration;\n\n            if (zoomOptions.area !== undefined) {\n                /* An area is given\n                 * We will define x/y coordinate AND a new zoom level to fill the area\n                 */\n                if (self.areas[zoomOptions.area] === undefined) throw new Error(\"Unknown area '\" + zoomOptions.area + \"'\");\n                var areaMargin = (zoomOptions.areaMargin !== undefined) ? zoomOptions.areaMargin : 10;\n                var areaBBox = self.areas[zoomOptions.area].mapElem.getBBox();\n                var areaFullWidth = areaBBox.width + 2 * areaMargin;\n                var areaFullHeight = areaBBox.height + 2 * areaMargin;\n\n                // Compute new x/y focus point (center of area)\n                zoomOptions.x = areaBBox.cx;\n                zoomOptions.y = areaBBox.cy;\n\n                // Compute a new absolute zoomLevel value (inverse of relative -> absolute)\n                // Take the min between zoomLevel on width vs. height to be able to see the whole area\n                zoomLevel = Math.min(Math.floor((self.mapConf.width / areaFullWidth - 1) / self.options.map.zoom.step),\n                                     Math.floor((self.mapConf.height / areaFullHeight - 1) / self.options.map.zoom.step));\n\n            } else {\n\n                // Get user defined zoom level\n                if (zoomOptions.level !== undefined) {\n                    if (typeof zoomOptions.level === \"string\") {\n                        // level is a string, either \"n\", \"+n\" or \"-n\"\n                        if ((zoomOptions.level.slice(0, 1) === '+') || (zoomOptions.level.slice(0, 1) === '-')) {\n                            // zoomLevel is relative\n                            zoomLevel = self.zoomData.zoomLevel + parseInt(zoomOptions.level, 10);\n                        } else {\n                            // zoomLevel is absolute\n                            zoomLevel = parseInt(zoomOptions.level, 10);\n                        }\n                    } else {\n                        // level is integer\n                        if (zoomOptions.level < 0) {\n                            // zoomLevel is relative\n                            zoomLevel = self.zoomData.zoomLevel + zoomOptions.level;\n                        } else {\n                            // zoomLevel is absolute\n                            zoomLevel = zoomOptions.level;\n                        }\n                    }\n                }\n\n                if (zoomOptions.plot !== undefined) {\n                    if (self.plots[zoomOptions.plot] === undefined) throw new Error(\"Unknown plot '\" + zoomOptions.plot + \"'\");\n\n                    zoomOptions.x = self.plots[zoomOptions.plot].coords.x;\n                    zoomOptions.y = self.plots[zoomOptions.plot].coords.y;\n                } else {\n                    if (zoomOptions.latitude !== undefined && zoomOptions.longitude !== undefined) {\n                        var coords = self.mapConf.getCoords(zoomOptions.latitude, zoomOptions.longitude);\n                        zoomOptions.x = coords.x;\n                        zoomOptions.y = coords.y;\n                    }\n\n                    if (zoomOptions.x === undefined) {\n                        zoomOptions.x = self.currentViewBox.x + self.currentViewBox.w / 2;\n                    }\n\n                    if (zoomOptions.y === undefined) {\n                        zoomOptions.y = self.currentViewBox.y + self.currentViewBox.h / 2;\n                    }\n                }\n            }\n\n            // Make sure we stay in the zoom level boundaries\n            zoomLevel = Math.min(Math.max(zoomLevel, self.options.map.zoom.minLevel), self.options.map.zoom.maxLevel);\n\n            // Compute relative zoom level\n            relativeZoomLevel = 1 + zoomLevel * self.options.map.zoom.step;\n\n            // Compute panWidth / panHeight\n            panWidth = self.mapConf.width / relativeZoomLevel;\n            panHeight = self.mapConf.height / relativeZoomLevel;\n\n            if (zoomLevel === 0) {\n                panX = 0;\n                panY = 0;\n            } else {\n                if (zoomOptions.fixedCenter !== undefined && zoomOptions.fixedCenter === true) {\n                    panX = self.zoomData.panX + ((zoomOptions.x - self.zoomData.panX) * (relativeZoomLevel - previousRelativeZoomLevel)) / relativeZoomLevel;\n                    panY = self.zoomData.panY + ((zoomOptions.y - self.zoomData.panY) * (relativeZoomLevel - previousRelativeZoomLevel)) / relativeZoomLevel;\n                } else {\n                    panX = zoomOptions.x - panWidth / 2;\n                    panY = zoomOptions.y - panHeight / 2;\n                }\n\n                // Make sure we stay in the map boundaries\n                panX = Math.min(Math.max(0, panX), self.mapConf.width - panWidth);\n                panY = Math.min(Math.max(0, panY), self.mapConf.height - panHeight);\n            }\n\n            // Update zoom level of the map\n            if (relativeZoomLevel === previousRelativeZoomLevel && panX === self.zoomData.panX && panY === self.zoomData.panY) return;\n\n            if (animDuration > 0) {\n                self.animateViewBox(panX, panY, panWidth, panHeight, animDuration, self.options.map.zoom.animEasing);\n            } else {\n                self.setViewBox(panX, panY, panWidth, panHeight);\n                clearTimeout(self.zoomTO);\n                self.zoomTO = setTimeout(function () {\n                    self.$map.trigger(\"afterZoom\", {\n                        x1: panX,\n                        y1: panY,\n                        x2: panX + panWidth,\n                        y2: panY + panHeight\n                    });\n                }, self.zoomFilteringTO);\n            }\n\n            $.extend(self.zoomData, {\n                zoomLevel: zoomLevel,\n                panX: panX,\n                panY: panY,\n                zoomX: panX + panWidth / 2,\n                zoomY: panY + panHeight / 2\n            });\n        },\n\n        /*\n         * Show some element in range defined by user\n         * Triggered by user $(\".mapcontainer\").trigger(\"showElementsInRange\", [opt]);\n         *\n         * @param opt the options\n         *  opt.hiddenOpacity opacity for hidden element (default = 0.3)\n         *  opt.animDuration animation duration in ms (default = 0)\n         *  opt.afterShowRange callback\n         *  opt.ranges the range to show:\n         *  Example:\n         *  opt.ranges = {\n         *      'plot' : {\n         *          0 : {                        // valueIndex\n         *              'min': 1000,\n         *              'max': 1200\n         *          },\n         *          1 : {                        // valueIndex\n         *              'min': 10,\n         *              'max': 12\n         *          }\n         *      },\n         *      'area' : {\n         *          {'min': 10, 'max': 20}    // No valueIndex, only an object, use 0 as valueIndex (easy case)\n         *      }\n         *  }\n         */\n        onShowElementsInRange: function(e, opt) {\n            var self = this;\n\n            // set animDuration to default if not defined\n            if (opt.animDuration === undefined) {\n                opt.animDuration = 0;\n            }\n\n            // set hiddenOpacity to default if not defined\n            if (opt.hiddenOpacity === undefined) {\n                opt.hiddenOpacity = 0.3;\n            }\n\n            // handle area\n            if (opt.ranges && opt.ranges.area) {\n                self.showElemByRange(opt.ranges.area, self.areas, opt.hiddenOpacity, opt.animDuration);\n            }\n\n            // handle plot\n            if (opt.ranges && opt.ranges.plot) {\n                self.showElemByRange(opt.ranges.plot, self.plots, opt.hiddenOpacity, opt.animDuration);\n            }\n\n            // handle link\n            if (opt.ranges && opt.ranges.link) {\n                self.showElemByRange(opt.ranges.link, self.links, opt.hiddenOpacity, opt.animDuration);\n            }\n\n            // Call user callback\n            if (opt.afterShowRange) opt.afterShowRange();\n        },\n\n        /*\n         * Show some element in range\n         * @param ranges: the ranges\n         * @param elems: list of element on which to check against previous range\n         * @hiddenOpacity: the opacity when hidden\n         * @animDuration: the animation duration\n         */\n        showElemByRange: function(ranges, elems, hiddenOpacity, animDuration) {\n            var self = this;\n            // Hold the final opacity value for all elements consolidated after applying each ranges\n            // This allow to set the opacity only once for each elements\n            var elemsFinalOpacity = {};\n\n            // set object with one valueIndex to 0 if we have directly the min/max\n            if (ranges.min !== undefined || ranges.max !== undefined) {\n                ranges = {0: ranges};\n            }\n\n            // Loop through each valueIndex\n            $.each(ranges, function (valueIndex) {\n                var range = ranges[valueIndex];\n                // Check if user defined at least a min or max value\n                if (range.min === undefined && range.max === undefined) {\n                    return true; // skip this iteration (each loop), goto next range\n                }\n                // Loop through each elements\n                $.each(elems, function (id) {\n                    var elemValue = elems[id].options.value;\n                    // set value with one valueIndex to 0 if not object\n                    if (typeof elemValue !== \"object\") {\n                        elemValue = [elemValue];\n                    }\n                    // Check existence of this value index\n                    if (elemValue[valueIndex] === undefined) {\n                        return true; // skip this iteration (each loop), goto next element\n                    }\n                    // Check if in range\n                    if ((range.min !== undefined && elemValue[valueIndex] < range.min) ||\n                        (range.max !== undefined && elemValue[valueIndex] > range.max)) {\n                        // Element not in range\n                        elemsFinalOpacity[id] = hiddenOpacity;\n                    } else {\n                        // Element in range\n                        elemsFinalOpacity[id] = 1;\n                    }\n                });\n            });\n            // Now that we looped through all ranges, we can really assign the final opacity\n            $.each(elemsFinalOpacity, function (id) {\n                self.setElementOpacity(elems[id], elemsFinalOpacity[id], animDuration);\n            });\n        },\n\n        /*\n         * Set element opacity\n         * Handle elem.mapElem and elem.textElem\n         * @param elem the element\n         * @param opacity the opacity to apply\n         * @param animDuration the animation duration to use\n         */\n        setElementOpacity: function(elem, opacity, animDuration) {\n            var self = this;\n\n            // Ensure no animation is running\n            //elem.mapElem.stop();\n            //if (elem.textElem) elem.textElem.stop();\n\n            // If final opacity is not null, ensure element is shown before proceeding\n            if (opacity > 0) {\n                elem.mapElem.show();\n                if (elem.textElem) elem.textElem.show();\n            }\n\n            self.animate(elem.mapElem, {\"opacity\": opacity}, animDuration, function () {\n                // If final attribute is 0, hide\n                if (opacity === 0) elem.mapElem.hide();\n            });\n\n            self.animate(elem.textElem, {\"opacity\": opacity}, animDuration, function () {\n                // If final attribute is 0, hide\n                if (opacity === 0) elem.textElem.hide();\n            });\n        },\n\n        /*\n         * Update the current map\n         *\n         * Refresh attributes and tooltips for areas and plots\n         * @param opt option for the refresh :\n         *  opt.mapOptions: options to update for plots and areas\n         *  opt.replaceOptions: whether mapsOptions should entirely replace current map options, or just extend it\n         *  opt.opt.newPlots new plots to add to the map\n         *  opt.newLinks new links to add to the map\n         *  opt.deletePlotKeys plots to delete from the map (array, or \"all\" to remove all plots)\n         *  opt.deleteLinkKeys links to remove from the map (array, or \"all\" to remove all links)\n         *  opt.setLegendElemsState the state of legend elements to be set : show (default) or hide\n         *  opt.animDuration animation duration in ms (default = 0)\n         *  opt.afterUpdate hook that allows to add custom processing on the map\n         */\n        onUpdateEvent: function (e, opt) {\n            var self = this;\n            // Abort if opt is undefined\n            if (typeof opt !== \"object\")  return;\n\n            var i = 0;\n            var animDuration = (opt.animDuration) ? opt.animDuration : 0;\n\n            // This function remove an element using animation (or not, depending on animDuration)\n            // Used for deletePlotKeys and deleteLinkKeys\n            var fnRemoveElement = function (elem) {\n\n                self.animate(elem.mapElem, {\"opacity\": 0}, animDuration, function () {\n                    elem.mapElem.remove();\n                });\n\n                self.animate(elem.textElem, {\"opacity\": 0}, animDuration, function () {\n                    elem.textElem.remove();\n                });\n            };\n\n            // This function show an element using animation\n            // Used for newPlots and newLinks\n            var fnShowElement = function (elem) {\n                // Starts with hidden elements\n                elem.mapElem.attr({opacity: 0});\n                if (elem.textElem) elem.textElem.attr({opacity: 0});\n                // Set final element opacity\n                self.setElementOpacity(\n                    elem,\n                    (elem.mapElem.originalAttrs.opacity !== undefined) ? elem.mapElem.originalAttrs.opacity : 1,\n                    animDuration\n                );\n            };\n\n            if (typeof opt.mapOptions === \"object\") {\n                if (opt.replaceOptions === true) self.options = self.extendDefaultOptions(opt.mapOptions);\n                else $.extend(true, self.options, opt.mapOptions);\n\n                // IF we update areas, plots or legend, then reset all legend state to \"show\"\n                if (opt.mapOptions.areas !== undefined || opt.mapOptions.plots !== undefined || opt.mapOptions.legend !== undefined) {\n                    $(\"[data-type='legend-elem']\", self.$container).each(function (id, elem) {\n                        if ($(elem).attr('data-hidden') === \"1\") {\n                            // Toggle state of element by clicking\n                            $(elem).trigger(\"click\", {hideOtherElems: false, animDuration: animDuration});\n                        }\n                    });\n                }\n            }\n\n            // Delete plots by name if deletePlotKeys is array\n            if (typeof opt.deletePlotKeys === \"object\") {\n                for (; i < opt.deletePlotKeys.length; i++) {\n                    if (self.plots[opt.deletePlotKeys[i]] !== undefined) {\n                        fnRemoveElement(self.plots[opt.deletePlotKeys[i]]);\n                        delete self.plots[opt.deletePlotKeys[i]];\n                    }\n                }\n                // Delete ALL plots if deletePlotKeys is set to \"all\"\n            } else if (opt.deletePlotKeys === \"all\") {\n                $.each(self.plots, function (id, elem) {\n                    fnRemoveElement(elem);\n                });\n                // Empty plots object\n                self.plots = {};\n            }\n\n            // Delete links by name if deleteLinkKeys is array\n            if (typeof opt.deleteLinkKeys === \"object\") {\n                for (i = 0; i < opt.deleteLinkKeys.length; i++) {\n                    if (self.links[opt.deleteLinkKeys[i]] !== undefined) {\n                        fnRemoveElement(self.links[opt.deleteLinkKeys[i]]);\n                        delete self.links[opt.deleteLinkKeys[i]];\n                    }\n                }\n                // Delete ALL links if deleteLinkKeys is set to \"all\"\n            } else if (opt.deleteLinkKeys === \"all\") {\n                $.each(self.links, function (id, elem) {\n                    fnRemoveElement(elem);\n                });\n                // Empty links object\n                self.links = {};\n            }\n\n            // New plots\n            if (typeof opt.newPlots === \"object\") {\n                $.each(opt.newPlots, function (id) {\n                    if (self.plots[id] === undefined) {\n                        self.options.plots[id] = opt.newPlots[id];\n                        self.plots[id] = self.drawPlot(id);\n                        if (animDuration > 0) {\n                            fnShowElement(self.plots[id]);\n                        }\n                    }\n                });\n            }\n\n            // New links\n            if (typeof opt.newLinks === \"object\") {\n                var newLinks = self.drawLinksCollection(opt.newLinks);\n                $.extend(self.links, newLinks);\n                $.extend(self.options.links, opt.newLinks);\n                if (animDuration > 0) {\n                    $.each(newLinks, function (id) {\n                        fnShowElement(newLinks[id]);\n                    });\n                }\n            }\n\n            // Update areas attributes and tooltips\n            $.each(self.areas, function (id) {\n                // Avoid updating unchanged elements\n                if ((typeof opt.mapOptions === \"object\" &&\n                    (\n                        (typeof opt.mapOptions.map === \"object\" && typeof opt.mapOptions.map.defaultArea === \"object\") ||\n                        (typeof opt.mapOptions.areas === \"object\" && typeof opt.mapOptions.areas[id] === \"object\") ||\n                        (typeof opt.mapOptions.legend === \"object\" && typeof opt.mapOptions.legend.area === \"object\")\n                    )) || opt.replaceOptions === true\n                ) {\n                    self.areas[id].options = self.getElemOptions(\n                        self.options.map.defaultArea,\n                        (self.options.areas[id] ? self.options.areas[id] : {}),\n                        self.options.legend.area\n                    );\n                    self.updateElem(self.areas[id], animDuration);\n                }\n            });\n\n            // Update plots attributes and tooltips\n            $.each(self.plots, function (id) {\n                // Avoid updating unchanged elements\n                if ((typeof opt.mapOptions ===\"object\" &&\n                    (\n                        (typeof opt.mapOptions.map === \"object\" && typeof opt.mapOptions.map.defaultPlot === \"object\") ||\n                        (typeof opt.mapOptions.plots === \"object\" && typeof opt.mapOptions.plots[id] === \"object\") ||\n                        (typeof opt.mapOptions.legend === \"object\" && typeof opt.mapOptions.legend.plot === \"object\")\n                    )) || opt.replaceOptions === true\n                ) {\n                    self.plots[id].options = self.getElemOptions(\n                        self.options.map.defaultPlot,\n                        (self.options.plots[id] ? self.options.plots[id] : {}),\n                        self.options.legend.plot\n                    );\n\n                    self.setPlotCoords(self.plots[id]);\n                    self.setPlotAttributes(self.plots[id]);\n\n                    self.updateElem(self.plots[id], animDuration);\n                }\n            });\n\n            // Update links attributes and tooltips\n            $.each(self.links, function (id) {\n                // Avoid updating unchanged elements\n                if ((typeof opt.mapOptions === \"object\" &&\n                    (\n                        (typeof opt.mapOptions.map === \"object\" && typeof opt.mapOptions.map.defaultLink === \"object\") ||\n                        (typeof opt.mapOptions.links === \"object\" && typeof opt.mapOptions.links[id] === \"object\")\n                    )) || opt.replaceOptions === true\n                ) {\n                    self.links[id].options = self.getElemOptions(\n                        self.options.map.defaultLink,\n                        (self.options.links[id] ? self.options.links[id] : {}),\n                        {}\n                    );\n\n                    self.updateElem(self.links[id], animDuration);\n                }\n            });\n\n            // Update legends\n            if (opt.mapOptions && (\n                    (typeof opt.mapOptions.legend === \"object\") ||\n                    (typeof opt.mapOptions.map === \"object\" && typeof opt.mapOptions.map.defaultArea === \"object\") ||\n                    (typeof opt.mapOptions.map === \"object\" && typeof opt.mapOptions.map.defaultPlot === \"object\")\n                )) {\n                // Show all elements on the map before updating the legends\n                $(\"[data-type='legend-elem']\", self.$container).each(function (id, elem) {\n                    if ($(elem).attr('data-hidden') === \"1\") {\n                        $(elem).trigger(\"click\", {hideOtherElems: false, animDuration: animDuration});\n                    }\n                });\n\n                self.createLegends(\"area\", self.areas, 1);\n                if (self.options.map.width) {\n                    self.createLegends(\"plot\", self.plots, (self.options.map.width / self.mapConf.width));\n                } else {\n                    self.createLegends(\"plot\", self.plots, (self.$map.width() / self.mapConf.width));\n                }\n            }\n\n            // Hide/Show all elements based on showlegendElems\n            //      Toggle (i.e. click) only if:\n            //          - slice legend is shown AND we want to hide\n            //          - slice legend is hidden AND we want to show\n            if (typeof opt.setLegendElemsState === \"object\") {\n                // setLegendElemsState is an object listing the legend we want to hide/show\n                $.each(opt.setLegendElemsState, function (legendCSSClass, action) {\n                    // Search for the legend\n                    var $legend = self.$container.find(\".\" + legendCSSClass)[0];\n                    if ($legend !== undefined) {\n                        // Select all elem inside this legend\n                        $(\"[data-type='legend-elem']\", $legend).each(function (id, elem) {\n                            if (($(elem).attr('data-hidden') === \"0\" && action === \"hide\") ||\n                                ($(elem).attr('data-hidden') === \"1\" && action === \"show\")) {\n                                // Toggle state of element by clicking\n                                $(elem).trigger(\"click\", {hideOtherElems: false, animDuration: animDuration});\n                            }\n                        });\n                    }\n                });\n            } else {\n                // setLegendElemsState is a string, or is undefined\n                // Default : \"show\"\n                var action = (opt.setLegendElemsState === \"hide\") ? \"hide\" : \"show\";\n\n                $(\"[data-type='legend-elem']\", self.$container).each(function (id, elem) {\n                    if (($(elem).attr('data-hidden') === \"0\" && action === \"hide\") ||\n                        ($(elem).attr('data-hidden') === \"1\" && action === \"show\")) {\n                        // Toggle state of element by clicking\n                        $(elem).trigger(\"click\", {hideOtherElems: false, animDuration: animDuration});\n                    }\n                });\n            }\n\n            // Always rebind custom events on update\n            self.initDelegatedCustomEvents();\n\n            if (opt.afterUpdate) opt.afterUpdate(self.$container, self.paper, self.areas, self.plots, self.options, self.links);\n        },\n\n        /*\n         * Set plot coordinates\n         * @param plot object plot element\n         */\n        setPlotCoords: function(plot) {\n            var self = this;\n\n            if (plot.options.x !== undefined && plot.options.y !== undefined) {\n                plot.coords = {\n                    x: plot.options.x,\n                    y: plot.options.y\n                };\n            } else if (plot.options.plotsOn !== undefined && self.areas[plot.options.plotsOn] !== undefined) {\n                var areaBBox = self.areas[plot.options.plotsOn].mapElem.getBBox();\n                plot.coords = {\n                    x: areaBBox.cx,\n                    y: areaBBox.cy\n                };\n            } else {\n                plot.coords = self.mapConf.getCoords(plot.options.latitude, plot.options.longitude);\n            }\n        },\n\n        /*\n         * Set plot size attributes according to its type\n         * Note: for SVG, plot.mapElem needs to exists beforehand\n         * @param plot object plot element\n         */\n        setPlotAttributes: function(plot) {\n            if (plot.options.type === \"square\") {\n                plot.options.attrs.width = plot.options.size;\n                plot.options.attrs.height = plot.options.size;\n                plot.options.attrs.x = plot.coords.x - (plot.options.size / 2);\n                plot.options.attrs.y = plot.coords.y - (plot.options.size / 2);\n            } else if (plot.options.type === \"image\") {\n                plot.options.attrs.src = plot.options.url;\n                plot.options.attrs.width = plot.options.width;\n                plot.options.attrs.height = plot.options.height;\n                plot.options.attrs.x = plot.coords.x - (plot.options.width / 2);\n                plot.options.attrs.y = plot.coords.y - (plot.options.height / 2);\n            } else if (plot.options.type === \"svg\") {\n                plot.options.attrs.path = plot.options.path;\n\n                // Init transform string\n                if (plot.options.attrs.transform === undefined) {\n                    plot.options.attrs.transform = \"\";\n                }\n\n                // Retrieve original boundary box if not defined\n                if (plot.mapElem.originalBBox === undefined) {\n                    plot.mapElem.originalBBox = plot.mapElem.getBBox();\n                }\n\n                // The base transform will resize the SVG path to the one specified by width/height\n                // and also move the path to the actual coordinates\n                plot.mapElem.baseTransform = \"m\" + (plot.options.width / plot.mapElem.originalBBox.width) + \",0,0,\" +\n                                                   (plot.options.height / plot.mapElem.originalBBox.height) + \",\" +\n                                                   (plot.coords.x - plot.options.width / 2) + \",\" +\n                                                   (plot.coords.y - plot.options.height / 2);\n\n                plot.options.attrs.transform = plot.mapElem.baseTransform + plot.options.attrs.transform;\n\n            } else { // Default : circle\n                plot.options.attrs.x = plot.coords.x;\n                plot.options.attrs.y = plot.coords.y;\n                plot.options.attrs.r = plot.options.size / 2;\n            }\n        },\n\n        /*\n         * Draw all links between plots on the paper\n         */\n        drawLinksCollection: function (linksCollection) {\n            var self = this;\n            var p1 = {};\n            var p2 = {};\n            var coordsP1 = {};\n            var coordsP2 = {};\n            var links = {};\n\n            $.each(linksCollection, function (id) {\n                var elemOptions = self.getElemOptions(self.options.map.defaultLink, linksCollection[id], {});\n\n                if (typeof linksCollection[id].between[0] === 'string') {\n                    p1 = self.options.plots[linksCollection[id].between[0]];\n                } else {\n                    p1 = linksCollection[id].between[0];\n                }\n\n                if (typeof linksCollection[id].between[1] === 'string') {\n                    p2 = self.options.plots[linksCollection[id].between[1]];\n                } else {\n                    p2 = linksCollection[id].between[1];\n                }\n\n                if (p1.plotsOn !== undefined && self.areas[p1.plotsOn] !== undefined) {\n                    var p1BBox = self.areas[p1.plotsOn].mapElem.getBBox();\n                    coordsP1 = {\n                        x: p1BBox.cx,\n                        y: p1BBox.cy\n                    };\n                }\n                else if (p1.latitude !== undefined && p1.longitude !== undefined) {\n                    coordsP1 = self.mapConf.getCoords(p1.latitude, p1.longitude);\n                } else {\n                    coordsP1.x = p1.x;\n                    coordsP1.y = p1.y;\n                }\n\n                if (p2.plotsOn !== undefined && self.areas[p2.plotsOn] !== undefined) {\n                    var p2BBox = self.areas[p2.plotsOn].mapElem.getBBox();\n                    coordsP2 = {\n                        x: p2BBox.cx,\n                        y: p2BBox.cy\n                    };\n                }\n                else if (p2.latitude !== undefined && p2.longitude !== undefined) {\n                    coordsP2 = self.mapConf.getCoords(p2.latitude, p2.longitude);\n                } else {\n                    coordsP2.x = p2.x;\n                    coordsP2.y = p2.y;\n                }\n                links[id] = self.drawLink(id, coordsP1.x, coordsP1.y, coordsP2.x, coordsP2.y, elemOptions);\n            });\n            return links;\n        },\n\n        /*\n         * Draw a curved link between two couples of coordinates a(xa,ya) and b(xb, yb) on the paper\n         */\n        drawLink: function (id, xa, ya, xb, yb, elemOptions) {\n            var self = this;\n            var link = {\n                options: elemOptions\n            };\n            // Compute the \"curveto\" SVG point, d(x,y)\n            // c(xc, yc) is the center of (xa,ya) and (xb, yb)\n            var xc = (xa + xb) / 2;\n            var yc = (ya + yb) / 2;\n\n            // Equation for (cd) : y = acd * x + bcd (d is the cure point)\n            var acd = -1 / ((yb - ya) / (xb - xa));\n            var bcd = yc - acd * xc;\n\n            // dist(c,d) = dist(a,b) (=abDist)\n            var abDist = Math.sqrt((xb - xa) * (xb - xa) + (yb - ya) * (yb - ya));\n\n            // Solution for equation dist(cd) = sqrt((xd - xc)¬≤ + (yd - yc)¬≤)\n            // dist(c,d)¬≤ = (xd - xc)¬≤ + (yd - yc)¬≤\n            // We assume that dist(c,d) = dist(a,b)\n            // so : (xd - xc)¬≤ + (yd - yc)¬≤ - dist(a,b)¬≤ = 0\n            // With the factor : (xd - xc)¬≤ + (yd - yc)¬≤ - (factor*dist(a,b))¬≤ = 0\n            // (xd - xc)¬≤ + (acd*xd + bcd - yc)¬≤ - (factor*dist(a,b))¬≤ = 0\n            var a = 1 + acd * acd;\n            var b = -2 * xc + 2 * acd * bcd - 2 * acd * yc;\n            var c = xc * xc + bcd * bcd - bcd * yc - yc * bcd + yc * yc - ((elemOptions.factor * abDist) * (elemOptions.factor * abDist));\n            var delta = b * b - 4 * a * c;\n            var x = 0;\n            var y = 0;\n\n            // There are two solutions, we choose one or the other depending on the sign of the factor\n            if (elemOptions.factor > 0) {\n                x = (-b + Math.sqrt(delta)) / (2 * a);\n                y = acd * x + bcd;\n            } else {\n                x = (-b - Math.sqrt(delta)) / (2 * a);\n                y = acd * x + bcd;\n            }\n\n            link.mapElem = self.paper.path(\"m \" + xa + \",\" + ya + \" C \" + x + \",\" + y + \" \" + xb + \",\" + yb + \" \" + xb + \",\" + yb + \"\");\n\n            self.initElem(id, 'link', link);\n\n            return link;\n        },\n\n        /*\n         * Check wether newAttrs object bring modifications to originalAttrs object\n         */\n        isAttrsChanged: function(originalAttrs, newAttrs) {\n            for (var key in newAttrs) {\n                if (newAttrs.hasOwnProperty(key) && typeof originalAttrs[key] === 'undefined' || newAttrs[key] !== originalAttrs[key]) {\n                    return true;\n                }\n            }\n            return false;\n        },\n\n        /*\n         * Update the element \"elem\" on the map with the new options\n         */\n        updateElem: function (elem, animDuration) {\n            var self = this;\n            var mapElemBBox;\n            var plotOffsetX;\n            var plotOffsetY;\n\n            if (elem.options.toFront === true) {\n                elem.mapElem.toFront();\n            }\n\n            // Set the cursor attribute related to the HTML link\n            if (elem.options.href !== undefined) {\n                elem.options.attrs.cursor = \"pointer\";\n                if (elem.options.text) elem.options.text.attrs.cursor = \"pointer\";\n            } else {\n                // No HTML links, check if a cursor was defined to pointer\n                if (elem.mapElem.attrs.cursor === 'pointer') {\n                    elem.options.attrs.cursor = \"auto\";\n                    if (elem.options.text) elem.options.text.attrs.cursor = \"auto\";\n                }\n            }\n\n            // Update the label\n            if (elem.textElem) {\n                // Update text attr\n                elem.options.text.attrs.text = elem.options.text.content;\n\n                // Get mapElem size, and apply an offset to handle future width/height change\n                mapElemBBox = elem.mapElem.getBBox();\n                if (elem.options.size || (elem.options.width && elem.options.height)) {\n                    if (elem.options.type === \"image\" || elem.options.type === \"svg\") {\n                        plotOffsetX = (elem.options.width - mapElemBBox.width) / 2;\n                        plotOffsetY = (elem.options.height - mapElemBBox.height) / 2;\n                    } else {\n                        plotOffsetX = (elem.options.size - mapElemBBox.width) / 2;\n                        plotOffsetY = (elem.options.size - mapElemBBox.height) / 2;\n                    }\n                    mapElemBBox.x -= plotOffsetX;\n                    mapElemBBox.x2 += plotOffsetX;\n                    mapElemBBox.y -= plotOffsetY;\n                    mapElemBBox.y2 += plotOffsetY;\n                }\n\n                // Update position attr\n                var textPosition = self.getTextPosition(mapElemBBox, elem.options.text.position, elem.options.text.margin);\n                elem.options.text.attrs.x = textPosition.x;\n                elem.options.text.attrs.y = textPosition.y;\n                elem.options.text.attrs['text-anchor'] = textPosition.textAnchor;\n\n                // Update text element attrs and attrsHover\n                self.setHoverOptions(elem.textElem, elem.options.text.attrs, elem.options.text.attrsHover);\n\n                if (self.isAttrsChanged(elem.textElem.attrs, elem.options.text.attrs)) {\n                    self.animate(elem.textElem, elem.options.text.attrs, animDuration);\n                }\n            }\n\n            // Update elements attrs and attrsHover\n            self.setHoverOptions(elem.mapElem, elem.options.attrs, elem.options.attrsHover);\n\n            if (self.isAttrsChanged(elem.mapElem.attrs, elem.options.attrs)) {\n                self.animate(elem.mapElem, elem.options.attrs, animDuration);\n            }\n\n            // Update the cssClass\n            if (elem.options.cssClass !== undefined) {\n                $(elem.mapElem.node).removeClass().addClass(elem.options.cssClass);\n            }\n        },\n\n        /*\n         * Draw the plot\n         */\n        drawPlot: function (id) {\n            var self = this;\n            var plot = {};\n\n            // Get plot options and store it\n            plot.options = self.getElemOptions(\n                self.options.map.defaultPlot,\n                (self.options.plots[id] ? self.options.plots[id] : {}),\n                self.options.legend.plot\n            );\n\n            // Set plot coords\n            self.setPlotCoords(plot);\n\n            // Draw SVG before setPlotAttributes()\n            if (plot.options.type === \"svg\") {\n                plot.mapElem = self.paper.path(plot.options.path);\n            }\n\n            // Set plot size attrs\n            self.setPlotAttributes(plot);\n\n            // Draw other types of plots\n            if (plot.options.type === \"square\") {\n                plot.mapElem = self.paper.rect(\n                    plot.options.attrs.x,\n                    plot.options.attrs.y,\n                    plot.options.attrs.width,\n                    plot.options.attrs.height\n                );\n            } else if (plot.options.type === \"image\") {\n                plot.mapElem = self.paper.image(\n                    plot.options.attrs.src,\n                    plot.options.attrs.x,\n                    plot.options.attrs.y,\n                    plot.options.attrs.width,\n                    plot.options.attrs.height\n                );\n            } else if (plot.options.type === \"svg\") {\n                // Nothing to do\n            } else {\n                // Default = circle\n                plot.mapElem = self.paper.circle(\n                    plot.options.attrs.x,\n                    plot.options.attrs.y,\n                    plot.options.attrs.r\n                );\n            }\n\n            self.initElem(id, 'plot', plot);\n\n            return plot;\n        },\n\n        /*\n         * Set user defined handlers for events on areas and plots\n         * @param id the id of the element\n         * @param type the type of the element (area, plot, link)\n         * @param elem the element object {mapElem, textElem, options, ...}\n         */\n        setEventHandlers: function (id, type, elem) {\n            var self = this;\n            $.each(elem.options.eventHandlers, function (event) {\n                if (self.customEventHandlers[event] === undefined) self.customEventHandlers[event] = {};\n                if (self.customEventHandlers[event][type] === undefined) self.customEventHandlers[event][type] = {};\n                self.customEventHandlers[event][type][id] = elem;\n            });\n        },\n\n        /*\n         * Draw a legend for areas and / or plots\n         * @param legendOptions options for the legend to draw\n         * @param legendType the type of the legend : \"area\" or \"plot\"\n         * @param elems collection of plots or areas on the maps\n         * @param legendIndex index of the legend in the conf array\n         */\n        drawLegend: function (legendOptions, legendType, elems, scale, legendIndex) {\n            var self = this;\n            var $legend = {};\n            var legendPaper = {};\n            var width = 0;\n            var height = 0;\n            var title = null;\n            var titleBBox = null;\n            var legendElems = {};\n            var i = 0;\n            var x = 0;\n            var y = 0;\n            var yCenter = 0;\n            var sliceOptions = [];\n\n            $legend = $(\".\" + legendOptions.cssClass, self.$container);\n\n            // Save content for later\n            var initialHTMLContent = $legend.html();\n            $legend.empty();\n\n            legendPaper = new Raphael($legend.get(0));\n            // Set some data to object\n            $(legendPaper.canvas).attr({\"data-legend-type\": legendType, \"data-legend-id\": legendIndex});\n\n            height = width = 0;\n\n            // Set the title of the legend\n            if (legendOptions.title && legendOptions.title !== \"\") {\n                title = legendPaper.text(legendOptions.marginLeftTitle, 0, legendOptions.title).attr(legendOptions.titleAttrs);\n                titleBBox = title.getBBox();\n                title.attr({y: 0.5 * titleBBox.height});\n\n                width = legendOptions.marginLeftTitle + titleBBox.width;\n                height += legendOptions.marginBottomTitle + titleBBox.height;\n            }\n\n            // Calculate attrs (and width, height and r (radius)) for legend elements, and yCenter for horizontal legends\n\n            for (i = 0; i < legendOptions.slices.length; ++i) {\n                var yCenterCurrent = 0;\n\n                sliceOptions[i] = $.extend(true, {}, (legendType === \"plot\") ? self.options.map.defaultPlot : self.options.map.defaultArea, legendOptions.slices[i]);\n\n                if (legendOptions.slices[i].legendSpecificAttrs === undefined) {\n                    legendOptions.slices[i].legendSpecificAttrs = {};\n                }\n\n                $.extend(true, sliceOptions[i].attrs, legendOptions.slices[i].legendSpecificAttrs);\n\n                if (legendType === \"area\") {\n                    if (sliceOptions[i].attrs.width === undefined)\n                        sliceOptions[i].attrs.width = 30;\n                    if (sliceOptions[i].attrs.height === undefined)\n                        sliceOptions[i].attrs.height = 20;\n                } else if (sliceOptions[i].type === \"square\") {\n                    if (sliceOptions[i].attrs.width === undefined)\n                        sliceOptions[i].attrs.width = sliceOptions[i].size;\n                    if (sliceOptions[i].attrs.height === undefined)\n                        sliceOptions[i].attrs.height = sliceOptions[i].size;\n                } else if (sliceOptions[i].type === \"image\" || sliceOptions[i].type === \"svg\") {\n                    if (sliceOptions[i].attrs.width === undefined)\n                        sliceOptions[i].attrs.width = sliceOptions[i].width;\n                    if (sliceOptions[i].attrs.height === undefined)\n                        sliceOptions[i].attrs.height = sliceOptions[i].height;\n                } else {\n                    if (sliceOptions[i].attrs.r === undefined)\n                        sliceOptions[i].attrs.r = sliceOptions[i].size / 2;\n                }\n\n                // Compute yCenter for this legend slice\n                yCenterCurrent = legendOptions.marginBottomTitle;\n                // Add title height if it exists\n                if (title) {\n                    yCenterCurrent += titleBBox.height;\n                }\n                if (legendType === \"plot\" && (sliceOptions[i].type === undefined || sliceOptions[i].type === \"circle\")) {\n                    yCenterCurrent += scale * sliceOptions[i].attrs.r;\n                } else {\n                    yCenterCurrent += scale * sliceOptions[i].attrs.height / 2;\n                }\n                // Update yCenter if current larger\n                yCenter = Math.max(yCenter, yCenterCurrent);\n            }\n\n            if (legendOptions.mode === \"horizontal\") {\n                width = legendOptions.marginLeft;\n            }\n\n            // Draw legend elements (circle, square or image in vertical or horizontal mode)\n            for (i = 0; i < sliceOptions.length; ++i) {\n                var legendElem = {};\n                var legendElemBBox = {};\n                var legendLabel = {};\n\n                if (sliceOptions[i].display === undefined || sliceOptions[i].display === true) {\n                    if (legendType === \"area\") {\n                        if (legendOptions.mode === \"horizontal\") {\n                            x = width + legendOptions.marginLeft;\n                            y = yCenter - (0.5 * scale * sliceOptions[i].attrs.height);\n                        } else {\n                            x = legendOptions.marginLeft;\n                            y = height;\n                        }\n\n                        legendElem = legendPaper.rect(x, y, scale * (sliceOptions[i].attrs.width), scale * (sliceOptions[i].attrs.height));\n                    } else if (sliceOptions[i].type === \"square\") {\n                        if (legendOptions.mode === \"horizontal\") {\n                            x = width + legendOptions.marginLeft;\n                            y = yCenter - (0.5 * scale * sliceOptions[i].attrs.height);\n                        } else {\n                            x = legendOptions.marginLeft;\n                            y = height;\n                        }\n\n                        legendElem = legendPaper.rect(x, y, scale * (sliceOptions[i].attrs.width), scale * (sliceOptions[i].attrs.height));\n\n                    } else if (sliceOptions[i].type === \"image\" || sliceOptions[i].type === \"svg\") {\n                        if (legendOptions.mode === \"horizontal\") {\n                            x = width + legendOptions.marginLeft;\n                            y = yCenter - (0.5 * scale * sliceOptions[i].attrs.height);\n                        } else {\n                            x = legendOptions.marginLeft;\n                            y = height;\n                        }\n\n                        if (sliceOptions[i].type === \"image\") {\n                            legendElem = legendPaper.image(\n                                sliceOptions[i].url, x, y, scale * sliceOptions[i].attrs.width, scale * sliceOptions[i].attrs.height);\n                        } else {\n                            legendElem = legendPaper.path(sliceOptions[i].path);\n\n                            if (sliceOptions[i].attrs.transform === undefined) {\n                                sliceOptions[i].attrs.transform = \"\";\n                            }\n                            legendElemBBox = legendElem.getBBox();\n                            sliceOptions[i].attrs.transform = \"m\" + ((scale * sliceOptions[i].width) / legendElemBBox.width) + \",0,0,\" + ((scale * sliceOptions[i].height) / legendElemBBox.height) + \",\" + x + \",\" + y + sliceOptions[i].attrs.transform;\n                        }\n                    } else {\n                        if (legendOptions.mode === \"horizontal\") {\n                            x = width + legendOptions.marginLeft + scale * (sliceOptions[i].attrs.r);\n                            y = yCenter;\n                        } else {\n                            x = legendOptions.marginLeft + scale * (sliceOptions[i].attrs.r);\n                            y = height + scale * (sliceOptions[i].attrs.r);\n                        }\n                        legendElem = legendPaper.circle(x, y, scale * (sliceOptions[i].attrs.r));\n                    }\n\n                    // Set attrs to the element drawn above\n                    delete sliceOptions[i].attrs.width;\n                    delete sliceOptions[i].attrs.height;\n                    delete sliceOptions[i].attrs.r;\n                    legendElem.attr(sliceOptions[i].attrs);\n                    legendElemBBox = legendElem.getBBox();\n\n                    // Draw the label associated with the element\n                    if (legendOptions.mode === \"horizontal\") {\n                        x = width + legendOptions.marginLeft + legendElemBBox.width + legendOptions.marginLeftLabel;\n                        y = yCenter;\n                    } else {\n                        x = legendOptions.marginLeft + legendElemBBox.width + legendOptions.marginLeftLabel;\n                        y = height + (legendElemBBox.height / 2);\n                    }\n\n                    legendLabel = legendPaper.text(x, y, sliceOptions[i].label).attr(legendOptions.labelAttrs);\n\n                    // Update the width and height for the paper\n                    if (legendOptions.mode === \"horizontal\") {\n                        var currentHeight = legendOptions.marginBottom + legendElemBBox.height;\n                        width += legendOptions.marginLeft + legendElemBBox.width + legendOptions.marginLeftLabel + legendLabel.getBBox().width;\n                        if (sliceOptions[i].type !== \"image\" && legendType !== \"area\") {\n                            currentHeight += legendOptions.marginBottomTitle;\n                        }\n                        // Add title height if it exists\n                        if (title) {\n                            currentHeight += titleBBox.height;\n                        }\n                        height = Math.max(height, currentHeight);\n                    } else {\n                        width = Math.max(width, legendOptions.marginLeft + legendElemBBox.width + legendOptions.marginLeftLabel + legendLabel.getBBox().width);\n                        height += legendOptions.marginBottom + legendElemBBox.height;\n                    }\n\n                    // Set some data to elements\n                    $(legendElem.node).attr({\n                        \"data-legend-id\": legendIndex,\n                        \"data-legend-type\": legendType,\n                        \"data-type\": \"legend-elem\",\n                        \"data-id\": i,\n                        \"data-hidden\": 0\n                    });\n                    $(legendLabel.node).attr({\n                        \"data-legend-id\": legendIndex,\n                        \"data-legend-type\": legendType,\n                        \"data-type\": \"legend-label\",\n                        \"data-id\": i,\n                        \"data-hidden\": 0\n                    });\n\n                    // Set array content\n                    // We use similar names like map/plots/links\n                    legendElems[i] = {\n                        mapElem: legendElem,\n                        textElem: legendLabel\n                    };\n\n                    // Hide map elements when the user clicks on a legend item\n                    if (legendOptions.hideElemsOnClick.enabled) {\n                        // Hide/show elements when user clicks on a legend element\n                        legendLabel.attr({cursor: \"pointer\"});\n                        legendElem.attr({cursor: \"pointer\"});\n\n                        self.setHoverOptions(legendElem, sliceOptions[i].attrs, sliceOptions[i].attrs);\n                        self.setHoverOptions(legendLabel, legendOptions.labelAttrs, legendOptions.labelAttrsHover);\n\n                        if (sliceOptions[i].clicked !== undefined && sliceOptions[i].clicked === true) {\n                            self.handleClickOnLegendElem(legendElems[i], i, legendIndex, legendType, {hideOtherElems: false});\n                        }\n                    }\n                }\n            }\n\n            // VMLWidth option allows you to set static width for the legend\n            // only for VML render because text.getBBox() returns wrong values on IE6/7\n            if (Raphael.type !== \"SVG\" && legendOptions.VMLWidth)\n                width = legendOptions.VMLWidth;\n\n            legendPaper.setSize(width, height);\n\n            return {\n                container: $legend,\n                initialHTMLContent: initialHTMLContent,\n                elems: legendElems\n            };\n        },\n\n        /*\n         * Allow to hide elements of the map when the user clicks on a related legend item\n         * @param elem legend element\n         * @param id legend element ID\n         * @param legendIndex corresponding legend index\n         * @param legendType corresponding legend type (area or plot)\n         * @param opts object additionnal options\n         *          hideOtherElems boolean, if other elems shall be hidden\n         *          animDuration duration of animation\n         */\n        handleClickOnLegendElem: function(elem, id, legendIndex, legendType, opts) {\n            var self = this;\n            var legendOptions;\n            opts = opts || {};\n\n            if (!$.isArray(self.options.legend[legendType])) {\n                legendOptions = self.options.legend[legendType];\n            } else {\n                legendOptions = self.options.legend[legendType][legendIndex];\n            }\n\n            var legendElem = elem.mapElem;\n            var legendLabel = elem.textElem;\n            var $legendElem = $(legendElem.node);\n            var $legendLabel = $(legendLabel.node);\n            var sliceOptions = legendOptions.slices[id];\n            var mapElems = legendType === 'area' ? self.areas : self.plots;\n            // Check animDuration: if not set, this is a regular click, use the value specified in options\n            var animDuration = opts.animDuration !== undefined ? opts.animDuration : legendOptions.hideElemsOnClick.animDuration ;\n\n            var hidden = $legendElem.attr('data-hidden');\n            var hiddenNewAttr = (hidden === '0') ? {\"data-hidden\": '1'} : {\"data-hidden\": '0'};\n\n            if (hidden === '0') {\n                self.animate(legendLabel, {\"opacity\": 0.5}, animDuration);\n            } else {\n                self.animate(legendLabel, {\"opacity\": 1}, animDuration);\n            }\n\n            $.each(mapElems, function (y) {\n                var elemValue;\n\n                // Retreive stored data of element\n                //      'hidden-by' contains the list of legendIndex that is hiding this element\n                var hiddenBy = mapElems[y].mapElem.data('hidden-by');\n                // Set to empty object if undefined\n                if (hiddenBy === undefined) hiddenBy = {};\n\n                if ($.isArray(mapElems[y].options.value)) {\n                    elemValue = mapElems[y].options.value[legendIndex];\n                } else {\n                    elemValue = mapElems[y].options.value;\n                }\n\n                // Hide elements whose value matches with the slice of the clicked legend item\n                if (self.getLegendSlice(elemValue, legendOptions) === sliceOptions) {\n                    if (hidden === '0') { // we want to hide this element\n                        hiddenBy[legendIndex] = true; // add legendIndex to the data object for later use\n                        self.setElementOpacity(mapElems[y], legendOptions.hideElemsOnClick.opacity, animDuration);\n                    } else { // We want to show this element\n                        delete hiddenBy[legendIndex]; // Remove this legendIndex from object\n                        // Check if another legendIndex is defined\n                        // We will show this element only if no legend is no longer hiding it\n                        if ($.isEmptyObject(hiddenBy)) {\n                            self.setElementOpacity(\n                                mapElems[y],\n                                mapElems[y].mapElem.originalAttrs.opacity !== undefined ? mapElems[y].mapElem.originalAttrs.opacity : 1,\n                                animDuration\n                            );\n                        }\n                    }\n                    // Update elem data with new values\n                    mapElems[y].mapElem.data('hidden-by', hiddenBy);\n                }\n            });\n\n            $legendElem.attr(hiddenNewAttr);\n            $legendLabel.attr(hiddenNewAttr);\n\n            if ((opts.hideOtherElems === undefined || opts.hideOtherElems === true) && legendOptions.exclusive === true ) {\n                $(\"[data-type='legend-elem'][data-hidden=0]\", self.$container).each(function () {\n                    var $elem = $(this);\n                    if ($elem.attr('data-id') !== id) {\n                        $elem.trigger(\"click\", {hideOtherElems: false});\n                    }\n                });\n            }\n\n        },\n\n        /*\n         * Create all legends for a specified type (area or plot)\n         * @param legendType the type of the legend : \"area\" or \"plot\"\n         * @param elems collection of plots or areas displayed on the map\n         * @param scale scale ratio of the map\n         */\n        createLegends: function (legendType, elems, scale) {\n            var self = this;\n            var legendsOptions = self.options.legend[legendType];\n\n            if (!$.isArray(self.options.legend[legendType])) {\n                legendsOptions = [self.options.legend[legendType]];\n            }\n\n            self.legends[legendType] = {};\n            for (var j = 0; j < legendsOptions.length; ++j) {\n                if (legendsOptions[j].display === true  && $.isArray(legendsOptions[j].slices) && legendsOptions[j].slices.length > 0 &&\n                    legendsOptions[j].cssClass !== \"\" && $(\".\" + legendsOptions[j].cssClass, self.$container).length !== 0\n                ) {\n                    self.legends[legendType][j] = self.drawLegend(legendsOptions[j], legendType, elems, scale, j);\n                }\n            }\n        },\n\n        /*\n         * Set the attributes on hover and the attributes to restore for a map element\n         * @param elem the map element\n         * @param originalAttrs the original attributes to restore on mouseout event\n         * @param attrsHover the attributes to set on mouseover event\n         */\n        setHoverOptions: function (elem, originalAttrs, attrsHover) {\n            // Disable transform option on hover for VML (IE<9) because of several bugs\n            if (Raphael.type !== \"SVG\") delete attrsHover.transform;\n            elem.attrsHover = attrsHover;\n\n            if (elem.attrsHover.transform) elem.originalAttrs = $.extend({transform: \"s1\"}, originalAttrs);\n            else elem.originalAttrs = originalAttrs;\n        },\n\n        /*\n         * Set the behaviour when mouse enters element (\"mouseover\" event)\n         * It may be an area, a plot, a link or a legend element\n         * @param elem the map element\n         */\n        elemEnter: function (elem) {\n            var self = this;\n            if (elem === undefined) return;\n\n            /* Handle mapElem Hover attributes */\n            if (elem.mapElem !== undefined) {\n                self.animate(elem.mapElem, elem.mapElem.attrsHover, elem.mapElem.attrsHover.animDuration);\n            }\n\n            /* Handle textElem Hover attributes */\n            if (elem.textElem !== undefined) {\n                self.animate(elem.textElem, elem.textElem.attrsHover, elem.textElem.attrsHover.animDuration);\n            }\n\n            /* Handle tooltip init */\n            if (elem.options && elem.options.tooltip !== undefined) {\n                var content = '';\n                // Reset classes\n                self.$tooltip.removeClass().addClass(self.options.map.tooltip.cssClass);\n                // Get content\n                if (elem.options.tooltip.content !== undefined) {\n                    // if tooltip.content is function, call it. Otherwise, assign it directly.\n                    if (typeof elem.options.tooltip.content === \"function\") content = elem.options.tooltip.content(elem.mapElem);\n                    else content = elem.options.tooltip.content;\n                }\n                if (elem.options.tooltip.cssClass !== undefined) {\n                    self.$tooltip.addClass(elem.options.tooltip.cssClass);\n                }\n                self.$tooltip.html(content).css(\"display\", \"block\");\n            }\n\n            // workaround for older version of Raphael\n            if (elem.mapElem !== undefined || elem.textElem !== undefined) {\n                if (self.paper.safari) self.paper.safari();\n            }\n        },\n\n        /*\n         * Set the behaviour when mouse moves in element (\"mousemove\" event)\n         * @param elem the map element\n         */\n        elemHover: function (elem, event) {\n            var self = this;\n            if (elem === undefined) return;\n\n            /* Handle tooltip position update */\n            if (elem.options.tooltip !== undefined) {\n                var mouseX = event.pageX;\n                var mouseY = event.pageY;\n\n                var offsetLeft = 10;\n                var offsetTop = 20;\n                if (typeof elem.options.tooltip.offset === \"object\") {\n                    if (typeof elem.options.tooltip.offset.left !== \"undefined\") {\n                        offsetLeft = elem.options.tooltip.offset.left;\n                    }\n                    if (typeof elem.options.tooltip.offset.top !== \"undefined\") {\n                        offsetTop = elem.options.tooltip.offset.top;\n                    }\n                }\n\n                var tooltipPosition = {\n                    \"left\": Math.min(self.$map.width() - self.$tooltip.outerWidth() - 5,\n                                     mouseX - self.$map.offset().left + offsetLeft),\n                    \"top\": Math.min(self.$map.height() - self.$tooltip.outerHeight() - 5,\n                                    mouseY - self.$map.offset().top + offsetTop)\n                };\n\n                if (typeof elem.options.tooltip.overflow === \"object\") {\n                    if (elem.options.tooltip.overflow.right === true) {\n                        tooltipPosition.left = mouseX - self.$map.offset().left + 10;\n                    }\n                    if (elem.options.tooltip.overflow.bottom === true) {\n                        tooltipPosition.top = mouseY - self.$map.offset().top + 20;\n                    }\n                }\n\n                self.$tooltip.css(tooltipPosition);\n            }\n        },\n\n        /*\n         * Set the behaviour when mouse leaves element (\"mouseout\" event)\n         * It may be an area, a plot, a link or a legend element\n         * @param elem the map element\n         */\n        elemOut: function (elem) {\n            var self = this;\n            if (elem === undefined) return;\n\n            /* reset mapElem attributes */\n            if (elem.mapElem !== undefined) {\n                self.animate(elem.mapElem, elem.mapElem.originalAttrs, elem.mapElem.attrsHover.animDuration);\n            }\n\n            /* reset textElem attributes */\n            if (elem.textElem !== undefined) {\n                self.animate(elem.textElem, elem.textElem.originalAttrs, elem.textElem.attrsHover.animDuration);\n            }\n\n            /* reset tooltip */\n            if (elem.options && elem.options.tooltip !== undefined) {\n                self.$tooltip.css({\n                    'display': 'none',\n                    'top': -1000,\n                    'left': -1000\n                });\n            }\n\n            // workaround for older version of Raphael\n            if (elem.mapElem !== undefined || elem.textElem !== undefined) {\n                if (self.paper.safari) self.paper.safari();\n            }\n        },\n\n        /*\n         * Set the behaviour when mouse clicks element (\"click\" event)\n         * It may be an area, a plot or a link (but not a legend element which has its own function)\n         * @param elem the map element\n         */\n        elemClick: function (elem) {\n            var self = this;\n            if (elem === undefined) return;\n\n            /* Handle click when href defined */\n            if (!self.panning && elem.options.href !== undefined) {\n                window.open(elem.options.href, elem.options.target);\n            }\n        },\n\n        /*\n         * Get element options by merging default options, element options and legend options\n         * @param defaultOptions\n         * @param elemOptions\n         * @param legendOptions\n         */\n        getElemOptions: function (defaultOptions, elemOptions, legendOptions) {\n            var self = this;\n            var options = $.extend(true, {}, defaultOptions, elemOptions);\n            if (options.value !== undefined) {\n                if ($.isArray(legendOptions)) {\n                    for (var i = 0; i < legendOptions.length; ++i) {\n                        options = $.extend(true, {}, options, self.getLegendSlice(options.value[i], legendOptions[i]));\n                    }\n                } else {\n                    options = $.extend(true, {}, options, self.getLegendSlice(options.value, legendOptions));\n                }\n            }\n            return options;\n        },\n\n        /*\n         * Get the coordinates of the text relative to a bbox and a position\n         * @param bbox the boundary box of the element\n         * @param textPosition the wanted text position (inner, right, left, top or bottom)\n         * @param margin number or object {x: val, y:val} margin between the bbox and the text\n         */\n        getTextPosition: function (bbox, textPosition, margin) {\n            var textX = 0;\n            var textY = 0;\n            var textAnchor = \"\";\n\n            if (typeof margin === \"number\") {\n                if (textPosition === \"bottom\" || textPosition === \"top\") {\n                    margin = {x: 0, y: margin};\n                } else if (textPosition === \"right\" || textPosition === \"left\") {\n                    margin = {x: margin, y: 0};\n                } else {\n                    margin = {x: 0, y: 0};\n                }\n            }\n\n            switch (textPosition) {\n                case \"bottom\" :\n                    textX = ((bbox.x + bbox.x2) / 2) + margin.x;\n                    textY = bbox.y2 + margin.y;\n                    textAnchor = \"middle\";\n                    break;\n                case \"top\" :\n                    textX = ((bbox.x + bbox.x2) / 2) + margin.x;\n                    textY = bbox.y - margin.y;\n                    textAnchor = \"middle\";\n                    break;\n                case \"left\" :\n                    textX = bbox.x - margin.x;\n                    textY = ((bbox.y + bbox.y2) / 2) + margin.y;\n                    textAnchor = \"end\";\n                    break;\n                case \"right\" :\n                    textX = bbox.x2 + margin.x;\n                    textY = ((bbox.y + bbox.y2) / 2) + margin.y;\n                    textAnchor = \"start\";\n                    break;\n                default : // \"inner\" position\n                    textX = ((bbox.x + bbox.x2) / 2) + margin.x;\n                    textY = ((bbox.y + bbox.y2) / 2) + margin.y;\n                    textAnchor = \"middle\";\n            }\n            return {\"x\": textX, \"y\": textY, \"textAnchor\": textAnchor};\n        },\n\n        /*\n         * Get the legend conf matching with the value\n         * @param value the value to match with a slice in the legend\n         * @param legend the legend params object\n         * @return the legend slice matching with the value\n         */\n        getLegendSlice: function (value, legend) {\n            for (var i = 0; i < legend.slices.length; ++i) {\n                if ((legend.slices[i].sliceValue !== undefined && value === legend.slices[i].sliceValue) ||\n                    ((legend.slices[i].sliceValue === undefined) &&\n                        (legend.slices[i].min === undefined || value >= legend.slices[i].min) &&\n                        (legend.slices[i].max === undefined || value <= legend.slices[i].max))\n                ) {\n                    return legend.slices[i];\n                }\n            }\n            return {};\n        },\n\n        /*\n         * Animated view box changes\n         * As from http://code.voidblossom.com/animating-viewbox-easing-formulas/,\n         * (from https://github.com/theshaun works on mapael)\n         * @param x coordinate of the point to focus on\n         * @param y coordinate of the point to focus on\n         * @param w map defined width\n         * @param h map defined height\n         * @param duration defined length of time for animation\n         * @param easingFunction defined Raphael supported easing_formula to use\n         */\n        animateViewBox: function (targetX, targetY, targetW, targetH, duration, easingFunction) {\n            var self = this;\n\n            var cx = self.currentViewBox.x;\n            var dx = targetX - cx;\n            var cy = self.currentViewBox.y;\n            var dy = targetY - cy;\n            var cw = self.currentViewBox.w;\n            var dw = targetW - cw;\n            var ch = self.currentViewBox.h;\n            var dh = targetH - ch;\n\n            // Init current ViewBox target if undefined\n            if (!self.zoomAnimCVBTarget) {\n                self.zoomAnimCVBTarget = {\n                    x: targetX, y: targetY, w: targetW, h: targetH\n                };\n            }\n\n            // Determine zoom direction by comparig current vs. target width\n            var zoomDir = (cw > targetW) ? 'in' : 'out';\n\n            var easingFormula = Raphael.easing_formulas[easingFunction || \"linear\"];\n\n            // To avoid another frame when elapsed time approach end (2%)\n            var durationWithMargin = duration - (duration * 2 / 100);\n\n            // Save current zoomAnimStartTime before assigning a new one\n            var oldZoomAnimStartTime = self.zoomAnimStartTime;\n            self.zoomAnimStartTime = (new Date()).getTime();\n\n            /* Actual function to animate the ViewBox\n             * Uses requestAnimationFrame to schedule itself again until animation is over\n             */\n            var computeNextStep = function () {\n                // Cancel any remaining animationFrame\n                // It means this new step will take precedence over the old one scheduled\n                // This is the case when the user is triggering the zoom fast (e.g. with a big mousewheel run)\n                // This actually does nothing when performing a single zoom action\n                self.cancelAnimationFrame(self.zoomAnimID);\n                // Compute elapsed time\n                var elapsed = (new Date()).getTime() - self.zoomAnimStartTime;\n                // Check if animation should finish\n                if (elapsed < durationWithMargin) {\n                    // Hold the future ViewBox values\n                    var x, y, w, h;\n\n                    // There are two ways to compute the next ViewBox size\n                    //  1. If the target ViewBox has changed between steps (=> ADAPTATION step)\n                    //  2. Or if the target ViewBox is the same (=> NORMAL step)\n                    //\n                    // A change of ViewBox target between steps means the user is triggering\n                    // the zoom fast (like a big scroll with its mousewheel)\n                    //\n                    // The new animation step with the new target will always take precedence over the\n                    // last one and start from 0 (we overwrite zoomAnimStartTime and cancel the scheduled frame)\n                    //\n                    // So if we don't detect the change of target and adapt our computation,\n                    // the user will see a delay at beginning the ratio will stays at 0 for some frames\n                    //\n                    // Hence when detecting the change of target, we animate from the previous target.\n                    //\n                    // The next step will then take the lead and continue from there, achieving a nicer\n                    // experience for user.\n\n                    // Change of target IF: an old animation start value exists AND the target has actually changed\n                    if (oldZoomAnimStartTime && self.zoomAnimCVBTarget && self.zoomAnimCVBTarget.w !== targetW) {\n                        // Compute the real time elapsed with the last step\n                        var realElapsed = (new Date()).getTime() - oldZoomAnimStartTime;\n                        // Compute then the actual ratio we're at\n                        var realRatio = easingFormula(realElapsed / duration);\n                        // Compute new ViewBox values\n                        // The difference with the normal function is regarding the delta  value used\n                        // We don't take the current (dx, dy, dw, dh) values yet because they are related to the new target\n                        // But we take the old target\n                        x = cx + (self.zoomAnimCVBTarget.x - cx) * realRatio;\n                        y = cy + (self.zoomAnimCVBTarget.y - cy) * realRatio;\n                        w = cw + (self.zoomAnimCVBTarget.w - cw) * realRatio;\n                        h = ch + (self.zoomAnimCVBTarget.h - ch) * realRatio;\n                        // Update cw, cy, cw and ch so the next step take animation from here\n                        cx = x;\n                        dx = targetX - cx;\n                        cy = y;\n                        dy = targetY - cy;\n                        cw = w;\n                        dw = targetW - cw;\n                        ch = h;\n                        dh = targetH - ch;\n                        // Update the current ViewBox target\n                        self.zoomAnimCVBTarget = {\n                            x: targetX, y: targetY, w: targetW, h: targetH\n                        };\n                    } else {\n                        // This is the classical approach when nothing come interrupting the zoom\n                        // Compute ratio according to elasped time and easing formula\n                        var ratio = easingFormula(elapsed / duration);\n                        // From the current value, we add a delta with a ratio that will leads us to the target\n                        x = cx + dx * ratio;\n                        y = cy + dy * ratio;\n                        w = cw + dw * ratio;\n                        h = ch + dh * ratio;\n                    }\n\n                    // Some checks before applying the new viewBox\n                    if (zoomDir === 'in' && (w > self.currentViewBox.w || w < targetW)) {\n                        // Zooming IN and the new ViewBox seems larger than the current value, or smaller than target value\n                        // We do NOT set the ViewBox with this value\n                        // Otherwise, the user would see the camera going back and forth\n                    } else if (zoomDir === 'out' && (w < self.currentViewBox.w || w > targetW)) {\n                        // Zooming OUT and the new ViewBox seems smaller than the current value, or larger than target value\n                        // We do NOT set the ViewBox with this value\n                        // Otherwise, the user would see the camera going back and forth\n                    } else {\n                        // New values look good, applying\n                        self.setViewBox(x, y, w, h);\n                    }\n\n                    // Schedule the next step\n                    self.zoomAnimID = self.requestAnimationFrame(computeNextStep);\n                } else {\n                    /* Zoom animation done ! */\n                    // Perform some cleaning\n                    self.zoomAnimStartTime = null;\n                    self.zoomAnimCVBTarget = null;\n                    // Make sure the ViewBox hits the target!\n                    if (self.currentViewBox.w !== targetW) {\n                        self.setViewBox(targetX, targetY, targetW, targetH);\n                    }\n                    // Finally trigger afterZoom event\n                    self.$map.trigger(\"afterZoom\", {\n                        x1: targetX, y1: targetY,\n                        x2: (targetX + targetW), y2: (targetY + targetH)\n                    });\n                }\n            };\n\n            // Invoke the first step directly\n            computeNextStep();\n        },\n\n        /*\n         * requestAnimationFrame/cancelAnimationFrame polyfill\n         * Based on https://gist.github.com/jlmakes/47eba84c54bc306186ac1ab2ffd336d4\n         * and also https://gist.github.com/paulirish/1579671\n         *\n         * _requestAnimationFrameFn and _cancelAnimationFrameFn hold the current functions\n         * But requestAnimationFrame and cancelAnimationFrame shall be called since\n         * in order to be in window context\n         */\n        // The function to use for requestAnimationFrame\n        requestAnimationFrame: function(callback) {\n            return this._requestAnimationFrameFn.call(window, callback);\n        },\n        // The function to use for cancelAnimationFrame\n        cancelAnimationFrame: function(id) {\n            this._cancelAnimationFrameFn.call(window, id);\n        },\n        // The requestAnimationFrame polyfill'd function\n        // Value set by self-invoking function, will be run only once\n        _requestAnimationFrameFn: (function () {\n            var polyfill = (function () {\n                var clock = (new Date()).getTime();\n\n                return function (callback) {\n                    var currentTime = (new Date()).getTime();\n\n                    // requestAnimationFrame strive to run @60FPS\n                    // (e.g. every 16 ms)\n                    if (currentTime - clock > 16) {\n                        clock = currentTime;\n                        callback(currentTime);\n                    } else {\n                        // Ask browser to schedule next callback when possible\n                        return setTimeout(function () {\n                            polyfill(callback);\n                        }, 0);\n                    }\n                };\n            })();\n\n            return window.requestAnimationFrame ||\n                window.webkitRequestAnimationFrame ||\n                window.mozRequestAnimationFrame ||\n                window.msRequestAnimationFrame ||\n                window.oRequestAnimationFrame ||\n                polyfill;\n        })(),\n        // The CancelAnimationFrame polyfill'd function\n        // Value set by self-invoking function, will be run only once\n        _cancelAnimationFrameFn: (function () {\n            return window.cancelAnimationFrame ||\n                window.webkitCancelAnimationFrame ||\n                window.webkitCancelRequestAnimationFrame ||\n                window.mozCancelAnimationFrame ||\n                window.mozCancelRequestAnimationFrame ||\n                window.msCancelAnimationFrame ||\n                window.msCancelRequestAnimationFrame ||\n                window.oCancelAnimationFrame ||\n                window.oCancelRequestAnimationFrame ||\n                clearTimeout;\n        })(),\n\n        /*\n         * SetViewBox wrapper\n         * Apply new viewbox values and keep track of them\n         *\n         * This avoid using the internal variable paper._viewBox which\n         * may not be present in future version of Raphael\n         */\n        setViewBox: function(x, y, w, h) {\n            var self = this;\n            // Update current value\n            self.currentViewBox.x = x;\n            self.currentViewBox.y = y;\n            self.currentViewBox.w = w;\n            self.currentViewBox.h = h;\n            // Perform set view box\n            self.paper.setViewBox(x, y, w, h, false);\n        },\n\n        /*\n         * Animate wrapper for Raphael element\n         *\n         * Perform an animation and ensure the non-animated attr are set.\n         * This is needed for specific attributes like cursor who will not\n         * be animated, and thus not set.\n         *\n         * If duration is set to 0 (or not set), no animation are performed\n         * and attributes are directly set (and the callback directly called)\n         */\n        // List extracted from Raphael internal vars\n        // Diff between Raphael.availableAttrs  and  Raphael._availableAnimAttrs\n        _nonAnimatedAttrs: [\n            \"arrow-end\", \"arrow-start\", \"gradient\",\n            \"class\", \"cursor\", \"text-anchor\",\n            \"font\", \"font-family\", \"font-style\", \"font-weight\", \"letter-spacing\",\n            \"src\", \"href\", \"target\", \"title\",\n            \"stroke-dasharray\", \"stroke-linecap\", \"stroke-linejoin\", \"stroke-miterlimit\"\n        ],\n        /*\n         * @param element Raphael element\n         * @param attrs Attributes object to animate\n         * @param duration Animation duration in ms\n         * @param callback Callback to eventually call after animation is done\n         */\n        animate: function(element, attrs, duration, callback) {\n            var self = this;\n            // Check element\n            if (!element) return;\n            if (duration > 0) {\n                // Filter out non-animated attributes\n                // Note: we don't need to delete from original attribute (they won't be set anyway)\n                var attrsNonAnimated = {};\n                for (var i=0 ; i < self._nonAnimatedAttrs.length ; i++) {\n                    var attrName = self._nonAnimatedAttrs[i];\n                    if (attrs[attrName] !== undefined) {\n                        attrsNonAnimated[attrName] = attrs[attrName];\n                    }\n                }\n                // Set non-animated attributes\n                element.attr(attrsNonAnimated);\n                // Start animation for all attributes\n                element.animate(attrs, duration, 'linear', function() {\n                    if (callback) callback();\n                });\n            } else {\n                // No animation: simply set all attributes...\n                element.attr(attrs);\n                // ... and call the callback if needed\n                if (callback) callback();\n            }\n        },\n\n        /*\n         * Check for Raphael bug regarding drawing while beeing hidden (under display:none)\n         * See https://github.com/neveldo/jQuery-Mapael/issues/135\n         * @return true/false\n         *\n         * Wants to override this behavior? Use prototype overriding:\n         *     $.mapael.prototype.isRaphaelBBoxBugPresent = function() {return false;};\n         */\n        isRaphaelBBoxBugPresent: function() {\n            var self = this;\n            // Draw text, then get its boundaries\n            var textElem = self.paper.text(-50, -50, \"TEST\");\n            var textElemBBox = textElem.getBBox();\n            // remove element\n            textElem.remove();\n            // If it has no height and width, then the paper is hidden\n            return (textElemBBox.width === 0 && textElemBBox.height === 0);\n        },\n\n        // Default map options\n        defaultOptions: {\n            map: {\n                cssClass: \"map\",\n                tooltip: {\n                    cssClass: \"mapTooltip\"\n                },\n                defaultArea: {\n                    attrs: {\n                        fill: \"#343434\",\n                        stroke: \"#5d5d5d\",\n                        \"stroke-width\": 1,\n                        \"stroke-linejoin\": \"round\"\n                    },\n                    attrsHover: {\n                        fill: \"#f38a03\",\n                        animDuration: 300\n                    },\n                    text: {\n                        position: \"inner\",\n                        margin: 10,\n                        attrs: {\n                            \"font-size\": 15,\n                            fill: \"#c7c7c7\"\n                        },\n                        attrsHover: {\n                            fill: \"#eaeaea\",\n                            \"animDuration\": 300\n                        }\n                    },\n                    target: \"_self\",\n                    cssClass: \"area\"\n                },\n                defaultPlot: {\n                    type: \"circle\",\n                    size: 15,\n                    attrs: {\n                        fill: \"#0088db\",\n                        stroke: \"#fff\",\n                        \"stroke-width\": 0,\n                        \"stroke-linejoin\": \"round\"\n                    },\n                    attrsHover: {\n                        \"stroke-width\": 3,\n                        animDuration: 300\n                    },\n                    text: {\n                        position: \"right\",\n                        margin: 10,\n                        attrs: {\n                            \"font-size\": 15,\n                            fill: \"#c7c7c7\"\n                        },\n                        attrsHover: {\n                            fill: \"#eaeaea\",\n                            animDuration: 300\n                        }\n                    },\n                    target: \"_self\",\n                    cssClass: \"plot\"\n                },\n                defaultLink: {\n                    factor: 0.5,\n                    attrs: {\n                        stroke: \"#0088db\",\n                        \"stroke-width\": 2\n                    },\n                    attrsHover: {\n                        animDuration: 300\n                    },\n                    text: {\n                        position: \"inner\",\n                        margin: 10,\n                        attrs: {\n                            \"font-size\": 15,\n                            fill: \"#c7c7c7\"\n                        },\n                        attrsHover: {\n                            fill: \"#eaeaea\",\n                            animDuration: 300\n                        }\n                    },\n                    target: \"_self\",\n                    cssClass: \"link\"\n                },\n                zoom: {\n                    enabled: false,\n                    minLevel: 0,\n                    maxLevel: 10,\n                    step: 0.25,\n                    mousewheel: true,\n                    touch: true,\n                    animDuration: 200,\n                    animEasing: \"linear\",\n                    buttons: {\n                        \"reset\": {\n                            cssClass: \"zoomButton zoomReset\",\n                            content: \"&#8226;\", // bullet sign\n                            title: \"Reset zoom\"\n                        },\n                        \"in\": {\n                            cssClass: \"zoomButton zoomIn\",\n                            content: \"+\",\n                            title: \"Zoom in\"\n                        },\n                        \"out\": {\n                            cssClass: \"zoomButton zoomOut\",\n                            content: \"&#8722;\", // minus sign\n                            title: \"Zoom out\"\n                        }\n                    }\n                }\n            },\n            legend: {\n                redrawOnResize: true,\n                area: [],\n                plot: []\n            },\n            areas: {},\n            plots: {},\n            links: {}\n        },\n\n        // Default legends option\n        legendDefaultOptions: {\n            area: {\n                cssClass: \"areaLegend\",\n                display: true,\n                marginLeft: 10,\n                marginLeftTitle: 5,\n                marginBottomTitle: 10,\n                marginLeftLabel: 10,\n                marginBottom: 10,\n                titleAttrs: {\n                    \"font-size\": 16,\n                    fill: \"#343434\",\n                    \"text-anchor\": \"start\"\n                },\n                labelAttrs: {\n                    \"font-size\": 12,\n                    fill: \"#343434\",\n                    \"text-anchor\": \"start\"\n                },\n                labelAttrsHover: {\n                    fill: \"#787878\",\n                    animDuration: 300\n                },\n                hideElemsOnClick: {\n                    enabled: true,\n                    opacity: 0.2,\n                    animDuration: 300\n                },\n                slices: [],\n                mode: \"vertical\"\n            },\n            plot: {\n                cssClass: \"plotLegend\",\n                display: true,\n                marginLeft: 10,\n                marginLeftTitle: 5,\n                marginBottomTitle: 10,\n                marginLeftLabel: 10,\n                marginBottom: 10,\n                titleAttrs: {\n                    \"font-size\": 16,\n                    fill: \"#343434\",\n                    \"text-anchor\": \"start\"\n                },\n                labelAttrs: {\n                    \"font-size\": 12,\n                    fill: \"#343434\",\n                    \"text-anchor\": \"start\"\n                },\n                labelAttrsHover: {\n                    fill: \"#787878\",\n                    animDuration: 300\n                },\n                hideElemsOnClick: {\n                    enabled: true,\n                    opacity: 0.2,\n                    animDuration: 300\n                },\n                slices: [],\n                mode: \"vertical\"\n            }\n        }\n\n    };\n\n    // Mapael version number\n    // Accessible as $.mapael.version\n    Mapael.version = version;\n\n    // Extend jQuery with Mapael\n    if ($[pluginName] === undefined) $[pluginName] = Mapael;\n\n    // Add jQuery DOM function\n    $.fn[pluginName] = function (options) {\n        // Call Mapael on each element\n        return this.each(function () {\n            // Avoid leaking problem on multiple instanciation by removing an old mapael object on a container\n            if ($.data(this, pluginName)) {\n                $.data(this, pluginName).destroy();\n            }\n            // Create Mapael and save it as jQuery data\n            // This allow external access to Mapael using $(\".mapcontainer\").data(\"mapael\")\n            $.data(this, pluginName, new Mapael(this, options));\n        });\n    };\n\n    return Mapael;\n\n}));\n\n\n//# sourceURL=webpack:///./node_modules/jquery-mapael/js/jquery.mapael.js?");

/***/ }),

/***/ "./node_modules/jquery-mousewheel/jquery.mousewheel.js":
/*!*************************************************************!*\
  !*** ./node_modules/jquery-mousewheel/jquery.mousewheel.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery Mousewheel 3.1.13\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n */\n\n(function (factory) {\n    if ( true ) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"jquery\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(function ($) {\n\n    var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],\n        toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?\n                    ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],\n        slice  = Array.prototype.slice,\n        nullLowestDeltaTimeout, lowestDelta;\n\n    if ( $.event.fixHooks ) {\n        for ( var i = toFix.length; i; ) {\n            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;\n        }\n    }\n\n    var special = $.event.special.mousewheel = {\n        version: '3.1.12',\n\n        setup: function() {\n            if ( this.addEventListener ) {\n                for ( var i = toBind.length; i; ) {\n                    this.addEventListener( toBind[--i], handler, false );\n                }\n            } else {\n                this.onmousewheel = handler;\n            }\n            // Store the line height and page height for this particular element\n            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));\n            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));\n        },\n\n        teardown: function() {\n            if ( this.removeEventListener ) {\n                for ( var i = toBind.length; i; ) {\n                    this.removeEventListener( toBind[--i], handler, false );\n                }\n            } else {\n                this.onmousewheel = null;\n            }\n            // Clean up the data we added to the element\n            $.removeData(this, 'mousewheel-line-height');\n            $.removeData(this, 'mousewheel-page-height');\n        },\n\n        getLineHeight: function(elem) {\n            var $elem = $(elem),\n                $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();\n            if (!$parent.length) {\n                $parent = $('body');\n            }\n            return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;\n        },\n\n        getPageHeight: function(elem) {\n            return $(elem).height();\n        },\n\n        settings: {\n            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below\n            normalizeOffset: true  // calls getBoundingClientRect for each event\n        }\n    };\n\n    $.fn.extend({\n        mousewheel: function(fn) {\n            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');\n        },\n\n        unmousewheel: function(fn) {\n            return this.unbind('mousewheel', fn);\n        }\n    });\n\n\n    function handler(event) {\n        var orgEvent   = event || window.event,\n            args       = slice.call(arguments, 1),\n            delta      = 0,\n            deltaX     = 0,\n            deltaY     = 0,\n            absDelta   = 0,\n            offsetX    = 0,\n            offsetY    = 0;\n        event = $.event.fix(orgEvent);\n        event.type = 'mousewheel';\n\n        // Old school scrollwheel delta\n        if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }\n        if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }\n        if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }\n        if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }\n\n        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event\n        if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {\n            deltaX = deltaY * -1;\n            deltaY = 0;\n        }\n\n        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy\n        delta = deltaY === 0 ? deltaX : deltaY;\n\n        // New school wheel delta (wheel event)\n        if ( 'deltaY' in orgEvent ) {\n            deltaY = orgEvent.deltaY * -1;\n            delta  = deltaY;\n        }\n        if ( 'deltaX' in orgEvent ) {\n            deltaX = orgEvent.deltaX;\n            if ( deltaY === 0 ) { delta  = deltaX * -1; }\n        }\n\n        // No change actually happened, no reason to go any further\n        if ( deltaY === 0 && deltaX === 0 ) { return; }\n\n        // Need to convert lines and pages to pixels if we aren't already in pixels\n        // There are three delta modes:\n        //   * deltaMode 0 is by pixels, nothing to do\n        //   * deltaMode 1 is by lines\n        //   * deltaMode 2 is by pages\n        if ( orgEvent.deltaMode === 1 ) {\n            var lineHeight = $.data(this, 'mousewheel-line-height');\n            delta  *= lineHeight;\n            deltaY *= lineHeight;\n            deltaX *= lineHeight;\n        } else if ( orgEvent.deltaMode === 2 ) {\n            var pageHeight = $.data(this, 'mousewheel-page-height');\n            delta  *= pageHeight;\n            deltaY *= pageHeight;\n            deltaX *= pageHeight;\n        }\n\n        // Store lowest absolute delta to normalize the delta values\n        absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );\n\n        if ( !lowestDelta || absDelta < lowestDelta ) {\n            lowestDelta = absDelta;\n\n            // Adjust older deltas if necessary\n            if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {\n                lowestDelta /= 40;\n            }\n        }\n\n        // Adjust older deltas if necessary\n        if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {\n            // Divide all the things by 40!\n            delta  /= 40;\n            deltaX /= 40;\n            deltaY /= 40;\n        }\n\n        // Get a whole, normalized value for the deltas\n        delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);\n        deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);\n        deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);\n\n        // Normalise offsetX and offsetY properties\n        if ( special.settings.normalizeOffset && this.getBoundingClientRect ) {\n            var boundingRect = this.getBoundingClientRect();\n            offsetX = event.clientX - boundingRect.left;\n            offsetY = event.clientY - boundingRect.top;\n        }\n\n        // Add information to the event object\n        event.deltaX = deltaX;\n        event.deltaY = deltaY;\n        event.deltaFactor = lowestDelta;\n        event.offsetX = offsetX;\n        event.offsetY = offsetY;\n        // Go ahead and set deltaMode to 0 since we converted to pixels\n        // Although this is a little odd since we overwrite the deltaX/Y\n        // properties with normalized deltas.\n        event.deltaMode = 0;\n\n        // Add event and delta to the front of the arguments\n        args.unshift(event, delta, deltaX, deltaY);\n\n        // Clearout lowestDelta after sometime to better\n        // handle multiple device types that give different\n        // a different lowestDelta\n        // Ex: trackpad = 3 and mouse wheel = 120\n        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }\n        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);\n\n        return ($.event.dispatch || $.event.handle).apply(this, args);\n    }\n\n    function nullLowestDelta() {\n        lowestDelta = null;\n    }\n\n    function shouldAdjustOldDeltas(orgEvent, absDelta) {\n        // If this is an older event and the delta is divisable by 120,\n        // then we are assuming that the browser is treating this as an\n        // older mouse wheel event and that we should divide the deltas\n        // by 40 to try and get a more usable deltaFactor.\n        // Side note, this actually impacts the reported scroll distance\n        // in older browsers and can cause scrolling to be slower than native.\n        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.\n        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;\n    }\n\n}));\n\n\n//# sourceURL=webpack:///./node_modules/jquery-mousewheel/jquery.mousewheel.js?");

/***/ }),

/***/ "jquery":
/*!********************************!*\
  !*** external "window.jQuery" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = window.jQuery;\n\n//# sourceURL=webpack:///external_%22window.jQuery%22?");

/***/ }),

/***/ "raphael":
/*!*********************************!*\
  !*** external "window.Raphael" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = window.Raphael;\n\n//# sourceURL=webpack:///external_%22window.Raphael%22?");

/***/ })

/******/ });
});;