
(function(r,f) {
    var a=f();
    if(typeof a!=='object')return;
    var e=[typeof module==='object'&&typeof module.exports==='object'?module.exports:null,typeof window!=='undefined'?window:null,r&&r!==window?r:null];
    for(var i in a){e[0]&&(e[0][i]=a[i]);e[1]&&i!=='__esModule'&&(e[1][i] = a[i]);e[2]&&(e[2][i]=a[i]);}
})(this,function(){
    return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./libs/tableexport/tableexport.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./libs/tableexport/tableexport.js":
/*!*****************************************!*\
  !*** ./libs/tableexport/tableexport.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ../../node_modules/tableexport.jquery.plugin/tableExport.js */ \"./node_modules/tableexport.jquery.plugin/tableExport.js\");\n\n\n//# sourceURL=webpack:///./libs/tableexport/tableexport.js?");

/***/ }),

/***/ "./node_modules/tableexport.jquery.plugin/tableExport.js":
/*!***************************************************************!*\
  !*** ./node_modules/tableexport.jquery.plugin/tableExport.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\r\n * @preserve tableExport.jquery.plugin\r\n *\r\n * Version 1.10.1\r\n *\r\n * Copyright (c) 2015-2018 hhurz, https://github.com/hhurz\r\n *\r\n * Original Work Copyright (c) 2014 Giri Raj\r\n *\r\n * Licensed under the MIT License\r\n **/\r\n\r\n\r\n\r\n(function ($) {\r\n  $.fn.tableExport = function (options) {\r\n    var defaults = {\r\n      csvEnclosure:        '\"',\r\n      csvSeparator:        ',',\r\n      csvUseBOM:           true,\r\n      displayTableName:    false,\r\n      escape:              false,\r\n      exportHiddenCells:   false,       // true = speed up export of large tables with hidden cells (hidden cells will be exported !)\r\n      fileName:            'tableExport',\r\n      htmlContent:         false,\r\n      ignoreColumn:        [],\r\n      ignoreRow:           [],\r\n      jsonScope:           'all',       // head, data, all\r\n      jspdf: {                          // jsPDF / jsPDF-AutoTable related options\r\n        orientation:       'p',\r\n        unit:              'pt',\r\n        format:            'a4',        // One of jsPDF page formats or 'bestfit' for autmatic paper format selection\r\n        margins:           {left: 20, right: 10, top: 10, bottom: 10},\r\n        onDocCreated:      null,\r\n        autotable: {\r\n          styles: {\r\n            cellPadding:   2,\r\n            rowHeight:     12,\r\n            fontSize:      8,\r\n            fillColor:     255,         // Color value or 'inherit' to use css background-color from html table\r\n            textColor:     50,          // Color value or 'inherit' to use css color from html table\r\n            fontStyle:     'normal',    // normal, bold, italic, bolditalic or 'inherit' to use css font-weight and fonst-style from html table\r\n            overflow:      'ellipsize', // visible, hidden, ellipsize or linebreak\r\n            halign:        'inherit',   // left, center, right or 'inherit' to use css horizontal cell alignment from html table\r\n            valign:        'middle'     // top, middle, bottom\r\n          },\r\n          headerStyles: {\r\n            fillColor:     [52, 73, 94],\r\n            textColor:     255,\r\n            fontStyle:     'bold',\r\n            halign:        'inherit',   // left, center, right or 'inherit' to use css horizontal header cell alignment from html table\r\n            valign:        'middle'     // top, middle, bottom\r\n          },\r\n          alternateRowStyles: {\r\n            fillColor:     245\r\n          },\r\n          tableExport: {\r\n            doc:               null,    // jsPDF doc object. If set, an already created doc will be used to export to\r\n            onAfterAutotable:  null,\r\n            onBeforeAutotable: null,\r\n            onAutotableText:   null,\r\n            onTable:           null,\r\n            outputImages:      true\r\n          }\r\n        }\r\n      },\r\n      mso: {                            // MS Excel and MS Word related options\r\n        fileFormat:        'xlshtml',   // xlshtml = Excel 2000 html format\r\n                                        // xmlss = XML Spreadsheet 2003 file format (XMLSS)\r\n                                        // xlsx = Excel 2007 Office Open XML format\r\n        onMsoNumberFormat: null,        // Excel 2000 html format only. See readme.md for more information about msonumberformat\r\n        pageFormat:        'a4',        // Page format used for page orientation\r\n        pageOrientation:   'portrait',  // portrait, landscape (xlshtml format only)\r\n        rtl:               false,       // true = Set worksheet option 'DisplayRightToLeft'\r\n        styles:            [],          // E.g. ['border-bottom', 'border-top', 'border-left', 'border-right']\r\n        worksheetName:     ''\r\n      },\r\n      numbers: {\r\n        html: {\r\n          decimalMark:        '.',\r\n          thousandsSeparator: ','\r\n        },\r\n        output: {                       // Use 'output: false' to keep number format in exported output\r\n          decimalMark:        '.',\r\n          thousandsSeparator: ','\r\n        }\r\n      },\r\n      onCellData:          null,\r\n      onCellHtmlData:      null,\r\n      onIgnoreRow:         null,        // onIgnoreRow($tr, rowIndex): function should return true to not export a row\r\n      outputMode:          'file',      // 'file', 'string', 'base64' or 'window' (experimental)\r\n      pdfmake: {\r\n        enabled:           false,       // true: use pdfmake instead of jspdf and jspdf-autotable (experimental)\r\n        docDefinition: {\r\n          pageOrientation: 'portrait',  // 'portrait' or 'landscape'\r\n          defaultStyle: {\r\n            font:          'Roboto'     // Default is 'Roboto', for arabic font set this option to 'Mirza' and include mirza_fonts.js\r\n          }\r\n        },\r\n        fonts: {}\r\n      },\r\n      preserve: {\r\n        leadingWS:         false,       // preserve leading white spaces\r\n        trailingWS:        false        // preserve trailing white spaces\r\n      },\r\n      preventInjection:    true,\r\n      tbodySelector:       'tr',\r\n      tfootSelector:       'tr',        // Set empty ('') to prevent export of tfoot rows\r\n      theadSelector:       'tr',\r\n      tableName:           'Table',\r\n      type:                'csv'        // 'csv', 'tsv', 'txt', 'sql', 'json', 'xml', 'excel', 'doc', 'png' or 'pdf'\r\n    };\r\n\r\n    var pageFormats = { // Size in pt of various paper formats. Adopted from jsPDF.\r\n      'a0': [2383.94, 3370.39], 'a1': [1683.78, 2383.94], 'a2': [1190.55, 1683.78],\r\n      'a3': [841.89, 1190.55],  'a4': [595.28, 841.89],   'a5': [419.53, 595.28],\r\n      'a6': [297.64, 419.53],   'a7': [209.76, 297.64],   'a8': [147.40, 209.76],\r\n      'a9': [104.88, 147.40],   'a10': [73.70, 104.88],\r\n      'b0': [2834.65, 4008.19], 'b1': [2004.09, 2834.65], 'b2': [1417.32, 2004.09],\r\n      'b3': [1000.63, 1417.32], 'b4': [708.66, 1000.63],  'b5': [498.90, 708.66],\r\n      'b6': [354.33, 498.90],   'b7': [249.45, 354.33],   'b8': [175.75, 249.45],\r\n      'b9': [124.72, 175.75],   'b10': [87.87, 124.72],\r\n      'c0': [2599.37, 3676.54],\r\n      'c1': [1836.85, 2599.37], 'c2': [1298.27, 1836.85], 'c3': [918.43, 1298.27],\r\n      'c4': [649.13, 918.43],   'c5': [459.21, 649.13],   'c6': [323.15, 459.21],\r\n      'c7': [229.61, 323.15],   'c8': [161.57, 229.61],   'c9': [113.39, 161.57],\r\n      'c10': [79.37, 113.39],\r\n      'dl': [311.81, 623.62],\r\n      'letter': [612, 792], 'government-letter': [576, 756], 'legal': [612, 1008],\r\n      'junior-legal': [576, 360], 'ledger': [1224, 792], 'tabloid': [792, 1224],\r\n      'credit-card': [153, 243]\r\n    };\r\n    var FONT_ROW_RATIO = 1.15;\r\n    var el             = this;\r\n    var DownloadEvt    = null;\r\n    var $hrows         = [];\r\n    var $rows          = [];\r\n    var rowIndex       = 0;\r\n    var trData         = '';\r\n    var colNames       = [];\r\n    var ranges         = [];\r\n    var blob;\r\n    var $hiddenTableElements = [];\r\n    var checkCellVisibilty = false;\r\n\r\n    $.extend(true, defaults, options);\r\n\r\n    // Adopt deprecated options\r\n    if (defaults.type === 'xlsx') {\r\n      defaults.mso.fileFormat = defaults.type;\r\n      defaults.type = 'excel';\r\n    }\r\n    if (typeof defaults.excelFileFormat !== 'undefined' && defaults.mso.fileFormat === 'undefined')\r\n      defaults.mso.fileFormat = defaults.excelFileFormat;\r\n    if (typeof defaults.excelPageFormat !== 'undefined' && defaults.mso.pageFormat === 'undefined')\r\n      defaults.mso.pageFormat = defaults.excelPageFormat;\r\n    if (typeof defaults.excelPageOrientation !== 'undefined' && defaults.mso.pageOrientation === 'undefined')\r\n      defaults.mso.pageOrientation = defaults.excelPageOrientation;\r\n    if (typeof defaults.excelRTL !== 'undefined' && defaults.mso.rtl === 'undefined')\r\n      defaults.mso.rtl = defaults.excelRTL;\r\n    if (typeof defaults.excelstyles !== 'undefined' && defaults.mso.styles === 'undefined')\r\n      defaults.mso.styles = defaults.excelstyles;\r\n    if (typeof defaults.onMsoNumberFormat !== 'undefined' && defaults.mso.onMsoNumberFormat === 'undefined')\r\n      defaults.mso.onMsoNumberFormat = defaults.onMsoNumberFormat;\r\n    if (typeof defaults.worksheetName !== 'undefined' && defaults.mso.worksheetName === 'undefined')\r\n      defaults.mso.worksheetName = defaults.worksheetName;\r\n\r\n    // Check values of some options\r\n    defaults.mso.pageOrientation = (defaults.mso.pageOrientation.substr(0, 1) === 'l') ? 'landscape' : 'portrait';\r\n\r\n    colNames = GetColumnNames(el);\r\n\r\n    if ( defaults.type === 'csv' || defaults.type === 'tsv' || defaults.type === 'txt' ) {\r\n\r\n      var csvData   = \"\";\r\n      var rowlength = 0;\r\n      ranges        = [];\r\n      rowIndex      = 0;\r\n\r\n      var csvString = function (cell, rowIndex, colIndex) {\r\n        var result = '';\r\n\r\n        if ( cell !== null ) {\r\n          var dataString = parseString(cell, rowIndex, colIndex);\r\n\r\n          var csvValue = (dataString === null || dataString === '') ? '' : dataString.toString();\r\n\r\n          if ( defaults.type === 'tsv' ) {\r\n            if ( dataString instanceof Date )\r\n              dataString.toLocaleString();\r\n\r\n            // According to http://www.iana.org/assignments/media-types/text/tab-separated-values\r\n            // are fields that contain tabs not allowable in tsv encoding\r\n            result = replaceAll(csvValue, '\\t', ' ');\r\n          }\r\n          else {\r\n            // Takes a string and encapsulates it (by default in double-quotes) if it\r\n            // contains the csv field separator, spaces, or linebreaks.\r\n            if ( dataString instanceof Date )\r\n              result = defaults.csvEnclosure + dataString.toLocaleString() + defaults.csvEnclosure;\r\n            else {\r\n              result = preventInjection(csvValue);\r\n              result = replaceAll(result, defaults.csvEnclosure, defaults.csvEnclosure + defaults.csvEnclosure);\r\n\r\n              if ( result.indexOf(defaults.csvSeparator) >= 0 || /[\\r\\n ]/g.test(result) )\r\n                result = defaults.csvEnclosure + result + defaults.csvEnclosure;\r\n            }\r\n          }\r\n        }\r\n\r\n        return result;\r\n      };\r\n\r\n      var CollectCsvData = function ($rows, rowselector, length) {\r\n\r\n        $rows.each(function () {\r\n          trData = \"\";\r\n          ForEachVisibleCell(this, rowselector, rowIndex, length + $rows.length,\r\n                             function (cell, row, col) {\r\n                               trData += csvString(cell, row, col) + (defaults.type === 'tsv' ? '\\t' : defaults.csvSeparator);\r\n                             });\r\n          trData = $.trim(trData).substring(0, trData.length - 1);\r\n          if ( trData.length > 0 ) {\r\n\r\n            if ( csvData.length > 0 )\r\n              csvData += \"\\n\";\r\n\r\n            csvData += trData;\r\n          }\r\n          rowIndex++;\r\n        });\r\n\r\n        return $rows.length;\r\n      };\r\n\r\n      rowlength += CollectCsvData($(el).find('thead').first().find(defaults.theadSelector), 'th,td', rowlength);\r\n      findTableElements($(el),'tbody').each(function () {\r\n        rowlength += CollectCsvData(findTableElements($(this), defaults.tbodySelector), 'td,th', rowlength);\r\n      });\r\n      if ( defaults.tfootSelector.length )\r\n        CollectCsvData($(el).find('tfoot').first().find(defaults.tfootSelector), 'td,th', rowlength);\r\n\r\n      csvData += \"\\n\";\r\n\r\n      //output\r\n      if ( defaults.outputMode === 'string' )\r\n        return csvData;\r\n\r\n      if ( defaults.outputMode === 'base64' )\r\n        return base64encode(csvData);\r\n\r\n      if ( defaults.outputMode === 'window' ) {\r\n        downloadFile(false, 'data:text/' + (defaults.type === 'csv' ? 'csv' : 'plain') + ';charset=utf-8,', csvData);\r\n        return;\r\n      }\r\n\r\n      try {\r\n        blob = new Blob([csvData], {type: \"text/\" + (defaults.type === 'csv' ? 'csv' : 'plain') + \";charset=utf-8\"});\r\n        saveAs(blob, defaults.fileName + '.' + defaults.type, (defaults.type !== 'csv' || defaults.csvUseBOM === false));\r\n      }\r\n      catch (e) {\r\n        downloadFile(defaults.fileName + '.' + defaults.type,\r\n          'data:text/' + (defaults.type === 'csv' ? 'csv' : 'plain') + ';charset=utf-8,' + ((defaults.type === 'csv' && defaults.csvUseBOM) ? '\\ufeff' : ''),\r\n          csvData);\r\n      }\r\n\r\n    } else if ( defaults.type === 'sql' ) {\r\n\r\n      // Header\r\n      rowIndex = 0;\r\n      ranges   = [];\r\n      var tdData = \"INSERT INTO `\" + defaults.tableName + \"` (\";\r\n      $hrows     = collectHeadRows ($(el));\r\n      $($hrows).each(function () {\r\n        ForEachVisibleCell(this, 'th,td', rowIndex, $hrows.length,\r\n                           function (cell, row, col) {\r\n                             tdData += \"'\" + parseString(cell, row, col) + \"',\";\r\n                           });\r\n        rowIndex++;\r\n        tdData = $.trim(tdData).substring(0, tdData.length - 1);\r\n      });\r\n      tdData += \") VALUES \";\r\n\r\n      // Data\r\n      $rows = collectRows ($(el));\r\n      $($rows).each(function () {\r\n        trData = \"\";\r\n        ForEachVisibleCell(this, 'td,th', rowIndex, $hrows.length + $rows.length,\r\n                           function (cell, row, col) {\r\n                             trData += \"'\" + parseString(cell, row, col) + \"',\";\r\n                           });\r\n        if ( trData.length > 3 ) {\r\n          tdData += \"(\" + trData;\r\n          tdData = $.trim(tdData).substring(0, tdData.length - 1);\r\n          tdData += \"),\";\r\n        }\r\n        rowIndex++;\r\n      });\r\n\r\n      tdData = $.trim(tdData).substring(0, tdData.length - 1);\r\n      tdData += \";\";\r\n\r\n      // Output\r\n      if ( defaults.outputMode === 'string' )\r\n        return tdData;\r\n\r\n      if ( defaults.outputMode === 'base64' )\r\n        return base64encode(tdData);\r\n\r\n      try {\r\n        blob = new Blob([tdData], {type: \"text/plain;charset=utf-8\"});\r\n        saveAs(blob, defaults.fileName + '.sql');\r\n      }\r\n      catch (e) {\r\n        downloadFile(defaults.fileName + '.sql',\r\n          'data:application/sql;charset=utf-8,',\r\n          tdData);\r\n      }\r\n\r\n    } else if ( defaults.type === 'json' ) {\r\n      var jsonHeaderArray = [];\r\n      ranges = [];\r\n      $hrows = collectHeadRows ($(el));\r\n      $($hrows).each(function () {\r\n        var jsonArrayTd = [];\r\n\r\n        ForEachVisibleCell(this, 'th,td', rowIndex, $hrows.length,\r\n                           function (cell, row, col) {\r\n                             jsonArrayTd.push(parseString(cell, row, col));\r\n                           });\r\n        jsonHeaderArray.push(jsonArrayTd);\r\n      });\r\n\r\n      // Data\r\n      var jsonArray = [];\r\n\r\n      $rows = collectRows ($(el));\r\n      $($rows).each(function () {\r\n        var jsonObjectTd = {};\r\n        var colIndex = 0;\r\n\r\n        ForEachVisibleCell(this, 'td,th', rowIndex, $hrows.length + $rows.length,\r\n                           function (cell, row, col) {\r\n                             if ( jsonHeaderArray.length ) {\r\n                               jsonObjectTd[jsonHeaderArray[jsonHeaderArray.length - 1][colIndex]] = parseString(cell, row, col);\r\n                             } else {\r\n                               jsonObjectTd[colIndex] = parseString(cell, row, col);\r\n                             }\r\n                             colIndex++;\r\n                           });\r\n        if ( $.isEmptyObject(jsonObjectTd) === false )\r\n          jsonArray.push(jsonObjectTd);\r\n\r\n        rowIndex++;\r\n      });\r\n\r\n      var sdata = \"\";\r\n\r\n      if ( defaults.jsonScope === 'head' )\r\n        sdata = JSON.stringify(jsonHeaderArray);\r\n      else if ( defaults.jsonScope === 'data' )\r\n        sdata = JSON.stringify(jsonArray);\r\n      else // all\r\n        sdata = JSON.stringify({header: jsonHeaderArray, data: jsonArray});\r\n\r\n      if ( defaults.outputMode === 'string' )\r\n        return sdata;\r\n\r\n      if ( defaults.outputMode === 'base64' )\r\n        return base64encode(sdata);\r\n\r\n      try {\r\n        blob = new Blob([sdata], {type: \"application/json;charset=utf-8\"});\r\n        saveAs(blob, defaults.fileName + '.json');\r\n      }\r\n      catch (e) {\r\n        downloadFile(defaults.fileName + '.json',\r\n          'data:application/json;charset=utf-8;base64,',\r\n          sdata);\r\n      }\r\n\r\n    } else if ( defaults.type === 'xml' ) {\r\n      rowIndex = 0;\r\n      ranges   = [];\r\n      var xml  = '<?xml version=\"1.0\" encoding=\"utf-8\"?>';\r\n      xml += '<tabledata><fields>';\r\n\r\n      // Header\r\n      $hrows = collectHeadRows ($(el));\r\n      $($hrows).each(function () {\r\n\r\n        ForEachVisibleCell(this, 'th,td', rowIndex, $hrows.length,\r\n                           function (cell, row, col) {\r\n                             xml += \"<field>\" + parseString(cell, row, col) + \"</field>\";\r\n                           });\r\n        rowIndex++;\r\n      });\r\n      xml += '</fields><data>';\r\n\r\n      // Data\r\n      var rowCount = 1;\r\n\r\n      $rows = collectRows ($(el));\r\n      $($rows).each(function () {\r\n        var colCount = 1;\r\n        trData       = \"\";\r\n        ForEachVisibleCell(this, 'td,th', rowIndex, $hrows.length + $rows.length,\r\n                           function (cell, row, col) {\r\n                             trData += \"<column-\" + colCount + \">\" + parseString(cell, row, col) + \"</column-\" + colCount + \">\";\r\n                             colCount++;\r\n                           });\r\n        if ( trData.length > 0 && trData !== \"<column-1></column-1>\" ) {\r\n          xml += '<row id=\"' + rowCount + '\">' + trData + '</row>';\r\n          rowCount++;\r\n        }\r\n\r\n        rowIndex++;\r\n      });\r\n      xml += '</data></tabledata>';\r\n\r\n      // Output\r\n      if ( defaults.outputMode === 'string' )\r\n        return xml;\r\n\r\n      if ( defaults.outputMode === 'base64' )\r\n        return base64encode(xml);\r\n\r\n      try {\r\n        blob = new Blob([xml], {type: \"application/xml;charset=utf-8\"});\r\n        saveAs(blob, defaults.fileName + '.xml');\r\n      }\r\n      catch (e) {\r\n        downloadFile(defaults.fileName + '.xml',\r\n          'data:application/xml;charset=utf-8;base64,',\r\n          xml);\r\n      }\r\n    }\r\n    else if ( defaults.type === 'excel' && defaults.mso.fileFormat === 'xmlss' ) {\r\n      var docDatas = [];\r\n      var docNames = [];\r\n\r\n      $(el).filter(function () {\r\n        return isVisible($(this));\r\n      }).each(function () {\r\n        var $table  = $(this);\r\n\r\n        var ssName = '';\r\n        if ( typeof defaults.mso.worksheetName === 'string' && defaults.mso.worksheetName.length )\r\n          ssName = defaults.mso.worksheetName + ' ' + (docNames.length + 1);\r\n        else if ( typeof defaults.mso.worksheetName[docNames.length] !== 'undefined' )\r\n          ssName = defaults.mso.worksheetName[docNames.length];\r\n        if ( ! ssName.length )\r\n          ssName = $table.find('caption').text() || '';\r\n        if ( ! ssName.length )\r\n          ssName = 'Table ' + (docNames.length + 1);\r\n        ssName = $.trim(ssName.replace(/[\\\\\\/[\\]*:?'\"]/g,'').substring(0,31));\r\n\r\n        docNames.push($('<div />').text(ssName).html());\r\n\r\n        if ( defaults.exportHiddenCells === false ) {\r\n          $hiddenTableElements = $table.find(\"tr, th, td\").filter(\":hidden\");\r\n          checkCellVisibilty = $hiddenTableElements.length > 0;\r\n        }\r\n\r\n        rowIndex = 0;\r\n        colNames = GetColumnNames(this);\r\n        docData  = '<Table>\\r';\r\n\r\n        function CollectXmlssData ($rows, rowselector, length) {\r\n          var spans = [];\r\n\r\n          $($rows).each(function () {\r\n            var ssIndex = 0;\r\n            var nCols = 0;\r\n            trData   = \"\";\r\n\r\n            ForEachVisibleCell(this, 'td,th', rowIndex, length + $rows.length,\r\n                               function (cell, row, col) {\r\n                                 if ( cell !== null ) {\r\n                                   var style = \"\";\r\n                                   var data  = parseString(cell, row, col);\r\n                                   var type  = \"String\";\r\n\r\n                                   if ( jQuery.isNumeric(data) !== false ) {\r\n                                     type = \"Number\";\r\n                                   }\r\n                                   else {\r\n                                     var number = parsePercent(data);\r\n                                     if ( number !== false ) {\r\n                                       data  = number;\r\n                                       type  = \"Number\";\r\n                                       style += ' ss:StyleID=\"pct1\"';\r\n                                     }\r\n                                   }\r\n\r\n                                   if ( type !== \"Number\" )\r\n                                     data = data.replace(/\\n/g, '<br>');\r\n\r\n                                   var colspan = getColspan (cell);\r\n                                   var rowspan = getRowspan (cell);\r\n\r\n                                   // Skip spans\r\n                                   $.each(spans, function () {\r\n                                     var range = this;\r\n                                     if ( rowIndex >= range.s.r && rowIndex <= range.e.r && nCols >= range.s.c && nCols <= range.e.c ) {\r\n                                       for ( var i = 0; i <= range.e.c - range.s.c; ++i ) {\r\n                                         nCols++;\r\n                                         ssIndex++;\r\n                                       }\r\n                                     }\r\n                                   });\r\n\r\n                                   // Handle Row Span\r\n                                   if ( rowspan || colspan ) {\r\n                                     rowspan = rowspan || 1;\r\n                                     colspan = colspan || 1;\r\n                                     spans.push({\r\n                                                  s: {r: rowIndex, c: nCols},\r\n                                                  e: {r: rowIndex + rowspan - 1, c: nCols + colspan - 1}\r\n                                                });\r\n                                   }\r\n\r\n                                   // Handle Colspan\r\n                                   if ( colspan > 1 ) {\r\n                                     style += ' ss:MergeAcross=\"' + (colspan-1) + '\"';\r\n                                     nCols += (colspan - 1);\r\n                                   }\r\n\r\n                                   if ( rowspan > 1 ) {\r\n                                     style += ' ss:MergeDown=\"' + (rowspan-1) + '\" ss:StyleID=\"rsp1\"';\r\n                                   }\r\n\r\n                                   if ( ssIndex > 0 ) {\r\n                                     style += ' ss:Index=\"' + (nCols+1) + '\"';\r\n                                     ssIndex = 0;\r\n                                   }\r\n\r\n                                   trData += '<Cell' + style + '><Data ss:Type=\"' + type + '\">' +\r\n                                     $('<div />').text(data).html() +\r\n                                     '</Data></Cell>\\r';\r\n                                   nCols++;\r\n                                 }\r\n                               });\r\n            if ( trData.length > 0 )\r\n              docData += '<Row ss:AutoFitHeight=\"0\">\\r' + trData + '</Row>\\r';\r\n            rowIndex++;\r\n          });\r\n\r\n          return $rows.length;\r\n        }\r\n\r\n        var rowLength = CollectXmlssData (collectHeadRows ($table), 'th,td', rowLength);\r\n        CollectXmlssData (collectRows ($table), 'td,th', rowLength);\r\n\r\n        docData += '</Table>\\r';\r\n        docDatas.push(docData);\r\n      });\r\n\r\n      var count = {};\r\n      var firstOccurences = {};\r\n      var item, itemCount;\r\n      for (var n = 0, c = docNames.length; n < c; n++)\r\n      {\r\n        item = docNames[n];\r\n        itemCount = count[item];\r\n        itemCount = count[item] = (itemCount == null ? 1 : itemCount + 1);\r\n\r\n        if( itemCount === 2 )\r\n          docNames[firstOccurences[item]] = docNames[firstOccurences[item]].substring(0,29) + \"-1\";\r\n        if( count[ item ] > 1 )\r\n          docNames[n] = docNames[n].substring(0,29) + \"-\" + count[item];\r\n        else\r\n          firstOccurences[item] = n;\r\n      }\r\n\r\n      var CreationDate = new Date().toISOString();\r\n      var xmlssDocFile = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\r' +\r\n        '<?mso-application progid=\"Excel.Sheet\"?>\\r' +\r\n        '<Workbook xmlns=\"urn:schemas-microsoft-com:office:spreadsheet\"\\r' +\r\n        ' xmlns:o=\"urn:schemas-microsoft-com:office:office\"\\r' +\r\n        ' xmlns:x=\"urn:schemas-microsoft-com:office:excel\"\\r' +\r\n        ' xmlns:ss=\"urn:schemas-microsoft-com:office:spreadsheet\"\\r' +\r\n        ' xmlns:html=\"http://www.w3.org/TR/REC-html40\">\\r' +\r\n        '<DocumentProperties xmlns=\"urn:schemas-microsoft-com:office:office\">\\r' +\r\n        '  <Created>' + CreationDate + '</Created>\\r' +\r\n        '</DocumentProperties>\\r' +\r\n        '<OfficeDocumentSettings xmlns=\"urn:schemas-microsoft-com:office:office\">\\r' +\r\n        '  <AllowPNG/>\\r' +\r\n        '</OfficeDocumentSettings>\\r' +\r\n        '<ExcelWorkbook xmlns=\"urn:schemas-microsoft-com:office:excel\">\\r' +\r\n        '  <WindowHeight>9000</WindowHeight>\\r' +\r\n        '  <WindowWidth>13860</WindowWidth>\\r' +\r\n        '  <WindowTopX>0</WindowTopX>\\r' +\r\n        '  <WindowTopY>0</WindowTopY>\\r' +\r\n        '  <ProtectStructure>False</ProtectStructure>\\r' +\r\n        '  <ProtectWindows>False</ProtectWindows>\\r' +\r\n        '</ExcelWorkbook>\\r' +\r\n        '<Styles>\\r' +\r\n        '  <Style ss:ID=\"Default\" ss:Name=\"Normal\">\\r' +\r\n        '    <Alignment ss:Vertical=\"Bottom\"/>\\r' +\r\n        '    <Borders/>\\r' +\r\n        '    <Font/>\\r' +\r\n        '    <Interior/>\\r' +\r\n        '    <NumberFormat/>\\r' +\r\n        '    <Protection/>\\r' +\r\n        '  </Style>\\r' +\r\n        '  <Style ss:ID=\"rsp1\">\\r' +\r\n        '    <Alignment ss:Vertical=\"Center\"/>\\r' +\r\n        '  </Style>\\r' +\r\n        '  <Style ss:ID=\"pct1\">\\r' +\r\n        '    <NumberFormat ss:Format=\"Percent\"/>\\r' +\r\n        '  </Style>\\r' +\r\n        '</Styles>\\r';\r\n\r\n      for ( var j = 0; j < docDatas.length; j++ ) {\r\n        xmlssDocFile += '<Worksheet ss:Name=\"' + docNames[j] + '\" ss:RightToLeft=\"' + (defaults.mso.rtl ? '1' : '0') + '\">\\r' +\r\n          docDatas[j];\r\n        if (defaults.mso.rtl) {\r\n          xmlssDocFile += '<WorksheetOptions xmlns=\"urn:schemas-microsoft-com:office:excel\">\\r' +\r\n            '<DisplayRightToLeft/>\\r' +\r\n            '</WorksheetOptions>\\r';\r\n        }\r\n        else\r\n          xmlssDocFile += '<WorksheetOptions xmlns=\"urn:schemas-microsoft-com:office:excel\"/>\\r';\r\n        xmlssDocFile += '</Worksheet>\\r';\r\n      }\r\n\r\n      xmlssDocFile += '</Workbook>\\r';\r\n\r\n      if ( defaults.outputMode === 'string' )\r\n        return xmlssDocFile;\r\n\r\n      if ( defaults.outputMode === 'base64' )\r\n        return base64encode(xmlssDocFile);\r\n\r\n      try {\r\n        blob = new Blob([xmlssDocFile], {type: \"application/xml;charset=utf-8\"});\r\n        saveAs(blob, defaults.fileName + '.xml');\r\n      }\r\n      catch (e) {\r\n        downloadFile(defaults.fileName + '.xml',\r\n          'data:application/xml;charset=utf-8;base64,',\r\n          xmlssDocFile);\r\n      }\r\n    }\r\n    else if ( defaults.type === 'excel' && defaults.mso.fileFormat === 'xlsx' ) {\r\n\r\n      var data  = [];\r\n      var spans = [];\r\n      rowIndex  = 0;\r\n\r\n      $rows = collectHeadRows ($(el));\r\n      $rows.push.apply($rows, collectRows ($(el)));\r\n\r\n      $($rows).each(function () {\r\n        var cols = [];\r\n        ForEachVisibleCell(this, 'th,td', rowIndex, $rows.length,\r\n                           function (cell, row, col) {\r\n                             if ( typeof cell !== 'undefined' && cell !== null ) {\r\n\r\n                               var cellValue = parseString(cell, row, col);\r\n\r\n                               var colspan = getColspan (cell);\r\n                               var rowspan = getRowspan (cell);\r\n\r\n                               // Skip span ranges\r\n                               $.each(spans, function () {\r\n                                 var range = this;\r\n                                 if ( rowIndex >= range.s.r && rowIndex <= range.e.r && cols.length >= range.s.c && cols.length <= range.e.c ) {\r\n                                   for ( var i = 0; i <= range.e.c - range.s.c; ++i )\r\n                                     cols.push(null);\r\n                                 }\r\n                               });\r\n\r\n                               // Handle Row Span\r\n                               if ( rowspan || colspan ) {\r\n                                 rowspan = rowspan || 1;\r\n                                 colspan = colspan || 1;\r\n                                 spans.push({\r\n                                              s: {r: rowIndex, c: cols.length},\r\n                                              e: {r: rowIndex + rowspan - 1, c: cols.length + colspan - 1}\r\n                                            });\r\n                               }\r\n\r\n                               // Handle Value\r\n                               if ( typeof defaults.onCellData !== 'function' ) {\r\n\r\n                                 // Type conversion\r\n                                 if ( cellValue !== \"\" && cellValue === +cellValue )\r\n                                   cellValue = +cellValue;\r\n                               }\r\n                               cols.push(cellValue !== \"\" ? cellValue : null);\r\n\r\n                               // Handle Colspan\r\n                               if ( colspan )\r\n                                 for ( var k = 0; k < colspan - 1; ++k )\r\n                                   cols.push(null);\r\n                             }\r\n                           });\r\n        data.push(cols);\r\n        rowIndex++;\r\n      });\r\n\r\n      //noinspection JSPotentiallyInvalidConstructorUsage\r\n      var wb = new jx_Workbook(),\r\n        ws = jx_createSheet(data);\r\n\r\n      // add span ranges to worksheet\r\n      ws['!merges'] = spans;\r\n\r\n      // add worksheet to workbook\r\n      //wb.SheetNames.push(defaults.mso.worksheetName);\r\n      //wb.Sheets[defaults.mso.worksheetName] = ws;\r\n      XLSX.utils.book_append_sheet(wb, ws, defaults.mso.worksheetName);\r\n\r\n      var wbout = XLSX.write(wb, {type: 'binary', bookType: defaults.mso.fileFormat, bookSST: false});\r\n\r\n      try {\r\n        blob = new Blob([jx_s2ab(wbout)], {type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8'});\r\n        saveAs(blob, defaults.fileName + '.' + defaults.mso.fileFormat);\r\n      }\r\n      catch (e) {\r\n        downloadFile(defaults.fileName + '.' + defaults.mso.fileFormat,\r\n          'data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8,',\r\n          jx_s2ab(wbout));\r\n      }\r\n    }\r\n    else if ( defaults.type === 'excel' || defaults.type === 'xls' || defaults.type === 'word' || defaults.type === 'doc' ) {\r\n\r\n      var MSDocType   = (defaults.type === 'excel' || defaults.type === 'xls') ? 'excel' : 'word';\r\n      var MSDocExt    = (MSDocType === 'excel') ? 'xls' : 'doc';\r\n      var MSDocSchema = 'xmlns:x=\"urn:schemas-microsoft-com:office:' + MSDocType + '\"';\r\n      var docData     = '';\r\n      var docName     = '';\r\n\r\n      $(el).filter(function () {\r\n        return isVisible($(this));\r\n      }).each(function () {\r\n        var $table = $(this);\r\n\r\n        if (docName === '') {\r\n          docName = defaults.mso.worksheetName || $table.find('caption').text() || 'Table';\r\n          docName = $.trim(docName.replace(/[\\\\\\/[\\]*:?'\"]/g, '').substring(0, 31));\r\n        }\r\n\r\n        if ( defaults.exportHiddenCells === false ) {\r\n          $hiddenTableElements = $table.find(\"tr, th, td\").filter(\":hidden\");\r\n          checkCellVisibilty = $hiddenTableElements.length > 0;\r\n        }\r\n\r\n        rowIndex = 0;\r\n        ranges   = [];\r\n        colNames = GetColumnNames(this);\r\n\r\n        // Header\r\n        docData += '<table><thead>';\r\n        $hrows = collectHeadRows ($table);\r\n        $($hrows).each(function () {\r\n          trData = \"\";\r\n          ForEachVisibleCell(this, 'th,td', rowIndex, $hrows.length,\r\n                             function (cell, row, col) {\r\n                               if ( cell !== null ) {\r\n                                 var thstyle = '';\r\n                                 trData += '<th';\r\n                                 for ( var styles in defaults.mso.styles ) {\r\n                                   if ( defaults.mso.styles.hasOwnProperty(styles) ) {\r\n                                     var thcss = $(cell).css(defaults.mso.styles[styles]);\r\n                                     if ( thcss !== '' && thcss !== '0px none rgb(0, 0, 0)' && thcss !== 'rgba(0, 0, 0, 0)' ) {\r\n                                       thstyle += (thstyle === '') ? 'style=\"' : ';';\r\n                                       thstyle += defaults.mso.styles[styles] + ':' + thcss;\r\n                                     }\r\n                                   }\r\n                                 }\r\n                                 if ( thstyle !== '' )\r\n                                   trData += ' ' + thstyle + '\"';\r\n\r\n                                 var tdcolspan = getColspan (cell);\r\n                                 if ( tdcolspan > 0 )\r\n                                   trData += ' colspan=\"' + tdcolspan + '\"';\r\n\r\n                                 var tdrowspan = getRowspan (cell);\r\n                                 if ( tdrowspan > 0 )\r\n                                   trData += ' rowspan=\"' + tdrowspan + '\"';\r\n\r\n                                 trData += '>' + parseString(cell, row, col) + '</th>';\r\n                               }\r\n                             });\r\n          if ( trData.length > 0 )\r\n            docData += '<tr>' + trData + '</tr>';\r\n          rowIndex++;\r\n        });\r\n        docData += '</thead><tbody>';\r\n\r\n        // Data\r\n        $rows = collectRows ($table);\r\n        $($rows).each(function () {\r\n          var $row = $(this);\r\n          trData   = \"\";\r\n          ForEachVisibleCell(this, 'td,th', rowIndex, $hrows.length + $rows.length,\r\n                             function (cell, row, col) {\r\n                               if ( cell !== null ) {\r\n                                 var tdvalue = parseString(cell, row, col);\r\n                                 var tdstyle = '';\r\n                                 var tdcss   = $(cell).data(\"tableexport-msonumberformat\");\r\n\r\n                                 if ( typeof tdcss === 'undefined' && typeof defaults.mso.onMsoNumberFormat === 'function' )\r\n                                   tdcss = defaults.mso.onMsoNumberFormat(cell, row, col);\r\n\r\n                                 if ( typeof tdcss !== 'undefined' && tdcss !== '' )\r\n                                   tdstyle = 'style=\"mso-number-format:\\'' + tdcss + '\\'';\r\n\r\n                                 for ( var cssStyle in defaults.mso.styles ) {\r\n                                   if ( defaults.mso.styles.hasOwnProperty(cssStyle) ) {\r\n                                     tdcss = $(cell).css(defaults.mso.styles[cssStyle]);\r\n                                     if ( tdcss === '' )\r\n                                       tdcss = $row.css(defaults.mso.styles[cssStyle]);\r\n\r\n                                     if ( tdcss !== '' && tdcss !== '0px none rgb(0, 0, 0)' && tdcss !== 'rgba(0, 0, 0, 0)' ) {\r\n                                       tdstyle += (tdstyle === '') ? 'style=\"' : ';';\r\n                                       tdstyle += defaults.mso.styles[cssStyle] + ':' + tdcss;\r\n                                     }\r\n                                   }\r\n                                 }\r\n                                 trData += '<td';\r\n                                 if ( tdstyle !== '' )\r\n                                   trData += ' ' + tdstyle + '\"';\r\n\r\n                                 var tdcolspan = getColspan (cell);\r\n                                 if ( tdcolspan > 0 )\r\n                                   trData += ' colspan=\"' + tdcolspan + '\"';\r\n\r\n                                 var tdrowspan = getRowspan (cell);\r\n                                 if ( tdrowspan > 0 )\r\n                                   trData += ' rowspan=\"' + tdrowspan + '\"';\r\n\r\n                                 if ( typeof tdvalue === 'string' && tdvalue !== '' ) {\r\n                                   tdvalue = preventInjection(tdvalue);\r\n                                   tdvalue = tdvalue.replace(/\\n/g, '<br>');\r\n                                 }\r\n\r\n                                 trData += '>' + tdvalue + '</td>';\r\n                               }\r\n                             });\r\n          if ( trData.length > 0 )\r\n            docData += '<tr>' + trData + '</tr>';\r\n          rowIndex++;\r\n        });\r\n\r\n        if ( defaults.displayTableName )\r\n          docData += '<tr><td></td></tr><tr><td></td></tr><tr><td>' + parseString($('<p>' + defaults.tableName + '</p>')) + '</td></tr>';\r\n\r\n        docData += '</tbody></table>';\r\n      });\r\n\r\n      //noinspection XmlUnusedNamespaceDeclaration\r\n      var docFile = '<html xmlns:o=\"urn:schemas-microsoft-com:office:office\" ' + MSDocSchema + ' xmlns=\"http://www.w3.org/TR/REC-html40\">';\r\n      docFile += '<meta http-equiv=\"content-type\" content=\"application/vnd.ms-' + MSDocType + '; charset=UTF-8\">';\r\n      docFile += \"<head>\";\r\n      if (MSDocType === 'excel') {\r\n        docFile += \"<!--[if gte mso 9]>\";\r\n        docFile += \"<xml>\";\r\n        docFile += \"<x:ExcelWorkbook>\";\r\n        docFile += \"<x:ExcelWorksheets>\";\r\n        docFile += \"<x:ExcelWorksheet>\";\r\n        docFile += \"<x:Name>\";\r\n        docFile += docName;\r\n        docFile += \"</x:Name>\";\r\n        docFile += \"<x:WorksheetOptions>\";\r\n        docFile += \"<x:DisplayGridlines/>\";\r\n        if (defaults.mso.rtl)\r\n          docFile += \"<x:DisplayRightToLeft/>\";\r\n        docFile += \"</x:WorksheetOptions>\";\r\n        docFile += \"</x:ExcelWorksheet>\";\r\n        docFile += \"</x:ExcelWorksheets>\";\r\n        docFile += \"</x:ExcelWorkbook>\";\r\n        docFile += \"</xml>\";\r\n        docFile += \"<![endif]-->\";\r\n      }\r\n      docFile += \"<style>\";\r\n\r\n      docFile += \"@page { size:\" + defaults.mso.pageOrientation + \"; mso-page-orientation:\" + defaults.mso.pageOrientation + \"; }\";\r\n      docFile += \"@page Section1 {size:\" + pageFormats[defaults.mso.pageFormat][0] + \"pt \" + pageFormats[defaults.mso.pageFormat][1] + \"pt\";\r\n      docFile += \"; margin:1.0in 1.25in 1.0in 1.25in;mso-header-margin:.5in;mso-footer-margin:.5in;mso-paper-source:0;}\";\r\n      docFile += \"div.Section1 {page:Section1;}\";\r\n      docFile += \"@page Section2 {size:\" + pageFormats[defaults.mso.pageFormat][1] + \"pt \" + pageFormats[defaults.mso.pageFormat][0] + \"pt\";\r\n      docFile += \";mso-page-orientation:\" + defaults.mso.pageOrientation + \";margin:1.25in 1.0in 1.25in 1.0in;mso-header-margin:.5in;mso-footer-margin:.5in;mso-paper-source:0;}\";\r\n      docFile += \"div.Section2 {page:Section2;}\";\r\n\r\n      docFile += \"br {mso-data-placement:same-cell;}\";\r\n      docFile += \"</style>\";\r\n      docFile += \"</head>\";\r\n      docFile += \"<body>\";\r\n      docFile += \"<div class=\\\"Section\" + ((defaults.mso.pageOrientation === 'landscape') ? \"2\" : \"1\") + \"\\\">\";\r\n      docFile += docData;\r\n      docFile += \"</div>\";\r\n      docFile += \"</body>\";\r\n      docFile += \"</html>\";\r\n\r\n      if ( defaults.outputMode === 'string' )\r\n        return docFile;\r\n\r\n      if ( defaults.outputMode === 'base64' )\r\n        return base64encode(docFile);\r\n\r\n      try {\r\n        blob = new Blob([docFile], {type: 'application/vnd.ms-' + defaults.type});\r\n        saveAs(blob, defaults.fileName + '.' + MSDocExt);\r\n      }\r\n      catch (e) {\r\n        downloadFile(defaults.fileName + '.' + MSDocExt,\r\n          'data:application/vnd.ms-' + MSDocType + ';base64,',\r\n          docFile);\r\n      }\r\n    }\r\n    else if ( defaults.type === 'png' ) {\r\n      //html2canvas($(el)[0], {\r\n      //  onrendered: function (canvas) {\r\n      html2canvas($(el)[0]).then(\r\n        function (canvas) {\r\n\r\n          var image      = canvas.toDataURL();\r\n          var byteString = atob(image.substring(22)); // remove data stuff\r\n          var buffer     = new ArrayBuffer(byteString.length);\r\n          var intArray   = new Uint8Array(buffer);\r\n\r\n          for ( var i = 0; i < byteString.length; i++ )\r\n            intArray[i] = byteString.charCodeAt(i);\r\n\r\n          if ( defaults.outputMode === 'string' )\r\n            return byteString;\r\n\r\n          if ( defaults.outputMode === 'base64' )\r\n            return base64encode(image);\r\n\r\n          if ( defaults.outputMode === 'window' ) {\r\n            window.open(image);\r\n            return;\r\n          }\r\n\r\n          try {\r\n            blob = new Blob([buffer], {type: \"image/png\"});\r\n            saveAs(blob, defaults.fileName + '.png');\r\n          }\r\n          catch (e) {\r\n            downloadFile(defaults.fileName + '.png', 'data:image/png,', blob);\r\n          }\r\n          //}\r\n        });\r\n\r\n    } else if ( defaults.type === 'pdf' ) {\r\n\r\n      if ( defaults.pdfmake.enabled === true ) {\r\n        // pdf output using pdfmake\r\n        // https://github.com/bpampuch/pdfmake\r\n\r\n        var widths = [];\r\n        var body   = [];\r\n        rowIndex   = 0;\r\n        ranges     = [];\r\n\r\n        /**\r\n         * @return {number}\r\n         */\r\n        var CollectPdfmakeData = function ($rows, colselector, length) {\r\n          var rlength = 0;\r\n\r\n          $($rows).each(function () {\r\n            var r = [];\r\n\r\n            ForEachVisibleCell(this, colselector, rowIndex, length,\r\n                               function (cell, row, col) {\r\n                                 if ( typeof cell !== 'undefined' && cell !== null ) {\r\n\r\n                                   var colspan = getColspan (cell);\r\n                                   var rowspan = getRowspan (cell);\r\n\r\n                                   var cellValue = parseString(cell, row, col) || \" \";\r\n\r\n                                   if ( colspan > 1 || rowspan > 1 ) {\r\n                                     colspan = colspan || 1;\r\n                                     rowspan = rowspan || 1;\r\n                                     r.push({colSpan: colspan, rowSpan: rowspan, text: cellValue});\r\n                                   }\r\n                                   else\r\n                                     r.push(cellValue);\r\n                                 }\r\n                                 else\r\n                                   r.push(\" \");\r\n                               });\r\n\r\n            if ( r.length )\r\n              body.push(r);\r\n\r\n            if ( rlength < r.length )\r\n              rlength = r.length;\r\n\r\n            rowIndex++;\r\n          });\r\n\r\n          return rlength;\r\n        };\r\n\r\n        $hrows = collectHeadRows ($(this));\r\n\r\n        var colcount = CollectPdfmakeData($hrows, 'th,td', $hrows.length);\r\n\r\n        for ( var i = widths.length; i < colcount; i++ )\r\n          widths.push(\"*\");\r\n\r\n        // Data\r\n        $rows = collectRows ($(this));\r\n\r\n        CollectPdfmakeData($rows, 'th,td', $hrows.length + $rows.length);\r\n\r\n        var docDefinition = {\r\n          content: [{\r\n            table: {\r\n              headerRows: $hrows.length,\r\n              widths:     widths,\r\n              body:       body\r\n            }\r\n          }]\r\n        };\r\n\r\n        $.extend(true, docDefinition, defaults.pdfmake.docDefinition);\r\n\r\n        pdfMake.fonts = {\r\n          Roboto: {\r\n            normal:      'Roboto-Regular.ttf',\r\n            bold:        'Roboto-Medium.ttf',\r\n            italics:     'Roboto-Italic.ttf',\r\n            bolditalics: 'Roboto-MediumItalic.ttf'\r\n          }\r\n        };\r\n\r\n        $.extend(true, pdfMake.fonts, defaults.pdfmake.fonts);\r\n\r\n        pdfMake.createPdf(docDefinition).getBuffer(function (buffer) {\r\n\r\n          try {\r\n            var blob = new Blob([buffer], {type: \"application/pdf\"});\r\n            saveAs(blob, defaults.fileName + '.pdf');\r\n          }\r\n          catch (e) {\r\n            downloadFile(defaults.fileName + '.pdf', 'application/pdf', buffer);\r\n          }\r\n        });\r\n\r\n      }\r\n      else if ( defaults.jspdf.autotable === false ) {\r\n        // pdf output using jsPDF's core html support\r\n\r\n        var addHtmlOptions = {\r\n          dim:       {\r\n            w: getPropertyUnitValue($(el).first().get(0), 'width', 'mm'),\r\n            h: getPropertyUnitValue($(el).first().get(0), 'height', 'mm')\r\n          },\r\n          pagesplit: false\r\n        };\r\n\r\n        var doc = new jsPDF(defaults.jspdf.orientation, defaults.jspdf.unit, defaults.jspdf.format);\r\n        doc.addHTML($(el).first(),\r\n                    defaults.jspdf.margins.left,\r\n                    defaults.jspdf.margins.top,\r\n                    addHtmlOptions,\r\n                    function () {\r\n                      jsPdfOutput(doc, false);\r\n                    });\r\n        //delete doc;\r\n      }\r\n      else {\r\n        // pdf output using jsPDF AutoTable plugin\r\n        // https://github.com/simonbengtsson/jsPDF-AutoTable\r\n\r\n        var teOptions = defaults.jspdf.autotable.tableExport;\r\n\r\n        // When setting jspdf.format to 'bestfit' tableExport tries to choose\r\n        // the minimum required paper format and orientation in which the table\r\n        // (or tables in multitable mode) completely fits without column adjustment\r\n        if ( typeof defaults.jspdf.format === 'string' && defaults.jspdf.format.toLowerCase() === 'bestfit' ) {\r\n          var rk = '', ro = '';\r\n          var mw = 0;\r\n\r\n          $(el).each(function () {\r\n            if ( isVisible($(this)) ) {\r\n              var w = getPropertyUnitValue($(this).get(0), 'width', 'pt');\r\n\r\n              if ( w > mw ) {\r\n                if ( w > pageFormats.a0[0] ) {\r\n                  rk = 'a0';\r\n                  ro = 'l';\r\n                }\r\n                for ( var key in pageFormats ) {\r\n                  if ( pageFormats.hasOwnProperty(key) ) {\r\n                    if ( pageFormats[key][1] > w ) {\r\n                      rk = key;\r\n                      ro = 'l';\r\n                      if ( pageFormats[key][0] > w )\r\n                        ro = 'p';\r\n                    }\r\n                  }\r\n                }\r\n                mw = w;\r\n              }\r\n            }\r\n          });\r\n          defaults.jspdf.format      = (rk === '' ? 'a4' : rk);\r\n          defaults.jspdf.orientation = (ro === '' ? 'w' : ro);\r\n        }\r\n\r\n        // The jsPDF doc object is stored in defaults.jspdf.autotable.tableExport,\r\n        // thus it can be accessed from any callback function\r\n        if ( teOptions.doc == null ) {\r\n          teOptions.doc = new jsPDF(defaults.jspdf.orientation,\r\n                                    defaults.jspdf.unit,\r\n                                    defaults.jspdf.format);\r\n\r\n          if ( typeof defaults.jspdf.onDocCreated === 'function' )\r\n            defaults.jspdf.onDocCreated(teOptions.doc);\r\n        }\r\n\r\n        if ( teOptions.outputImages === true )\r\n          teOptions.images = {};\r\n\r\n        if ( typeof teOptions.images !== 'undefined' ) {\r\n          $(el).filter(function () {\r\n            return isVisible($(this));\r\n          }).each(function () {\r\n            var rowCount = 0;\r\n            ranges       = [];\r\n\r\n            if ( defaults.exportHiddenCells === false ) {\r\n              $hiddenTableElements = $(this).find(\"tr, th, td\").filter(\":hidden\");\r\n              checkCellVisibilty = $hiddenTableElements.length > 0;\r\n            }\r\n\r\n            $hrows = collectHeadRows ($(this));\r\n            $rows = collectRows ($(this));\r\n\r\n            $($rows).each(function () {\r\n              ForEachVisibleCell(this, 'td,th', $hrows.length + rowCount, $hrows.length + $rows.length,\r\n                                 function (cell) {\r\n                                   collectImages(cell, $(cell).children(), teOptions);\r\n                                 });\r\n              rowCount++;\r\n            });\r\n          });\r\n\r\n          $hrows = [];\r\n          $rows  = [];\r\n        }\r\n\r\n        loadImages(teOptions, function () {\r\n          $(el).filter(function () {\r\n            return isVisible($(this));\r\n          }).each(function () {\r\n            var colKey;\r\n            rowIndex = 0;\r\n            ranges   = [];\r\n\r\n            if ( defaults.exportHiddenCells === false ) {\r\n              $hiddenTableElements = $(this).find(\"tr, th, td\").filter(\":hidden\");\r\n              checkCellVisibilty = $hiddenTableElements.length > 0;\r\n            }\r\n\r\n            colNames = GetColumnNames(this);\r\n\r\n            teOptions.columns = [];\r\n            teOptions.rows    = [];\r\n            teOptions.teCells = {};\r\n\r\n            // onTable: optional callback function for every matching table that can be used\r\n            // to modify the tableExport options or to skip the output of a particular table\r\n            // if the table selector targets multiple tables\r\n            if ( typeof teOptions.onTable === 'function' )\r\n              if ( teOptions.onTable($(this), defaults) === false )\r\n                return true; // continue to next iteration step (table)\r\n\r\n            // each table works with an own copy of AutoTable options\r\n            defaults.jspdf.autotable.tableExport = null;  // avoid deep recursion error\r\n            var atOptions                        = $.extend(true, {}, defaults.jspdf.autotable);\r\n            defaults.jspdf.autotable.tableExport = teOptions;\r\n\r\n            atOptions.margin = {};\r\n            $.extend(true, atOptions.margin, defaults.jspdf.margins);\r\n            atOptions.tableExport = teOptions;\r\n\r\n            // Fix jsPDF Autotable's row height calculation\r\n            if ( typeof atOptions.beforePageContent !== 'function' ) {\r\n              atOptions.beforePageContent = function (data) {\r\n                if ( data.pageCount === 1 ) {\r\n                  var all = data.table.rows.concat(data.table.headerRow);\r\n                  $.each(all, function () {\r\n                    var row = this;\r\n                    if ( row.height > 0 ) {\r\n                      row.height += (2 - FONT_ROW_RATIO) / 2 * row.styles.fontSize;\r\n                      data.table.height += (2 - FONT_ROW_RATIO) / 2 * row.styles.fontSize;\r\n                    }\r\n                  });\r\n                }\r\n              };\r\n            }\r\n\r\n            if ( typeof atOptions.createdHeaderCell !== 'function' ) {\r\n              // apply some original css styles to pdf header cells\r\n              atOptions.createdHeaderCell = function (cell, data) {\r\n\r\n                // jsPDF AutoTable plugin v2.0.14 fix: each cell needs its own styles object\r\n                cell.styles = $.extend({}, data.row.styles);\r\n\r\n                if ( typeof teOptions.columns [data.column.dataKey] !== 'undefined' ) {\r\n                  var col = teOptions.columns [data.column.dataKey];\r\n\r\n                  if ( typeof col.rect !== 'undefined' ) {\r\n                    var rh;\r\n\r\n                    cell.contentWidth = col.rect.width;\r\n\r\n                    if ( typeof teOptions.heightRatio === 'undefined' || teOptions.heightRatio === 0 ) {\r\n                      if ( data.row.raw [data.column.dataKey].rowspan )\r\n                        rh = data.row.raw [data.column.dataKey].rect.height / data.row.raw [data.column.dataKey].rowspan;\r\n                      else\r\n                        rh = data.row.raw [data.column.dataKey].rect.height;\r\n\r\n                      teOptions.heightRatio = cell.styles.rowHeight / rh;\r\n                    }\r\n\r\n                    rh = data.row.raw [data.column.dataKey].rect.height * teOptions.heightRatio;\r\n                    if ( rh > cell.styles.rowHeight )\r\n                      cell.styles.rowHeight = rh;\r\n                  }\r\n\r\n                  cell.styles.halign = (atOptions.headerStyles.halign === 'inherit') ? 'center' : atOptions.headerStyles.halign;\r\n                  cell.styles.valign = atOptions.headerStyles.valign;\r\n\r\n                  if ( typeof col.style !== 'undefined' && col.style.hidden !== true ) {\r\n                    if ( atOptions.headerStyles.halign === 'inherit' )\r\n                      cell.styles.halign = col.style.align;\r\n                    if ( atOptions.styles.fillColor === 'inherit' )\r\n                      cell.styles.fillColor = col.style.bcolor;\r\n                    if ( atOptions.styles.textColor === 'inherit' )\r\n                      cell.styles.textColor = col.style.color;\r\n                    if ( atOptions.styles.fontStyle === 'inherit' )\r\n                      cell.styles.fontStyle = col.style.fstyle;\r\n                  }\r\n                }\r\n              };\r\n            }\r\n\r\n            if ( typeof atOptions.createdCell !== 'function' ) {\r\n              // apply some original css styles to pdf table cells\r\n              atOptions.createdCell = function (cell, data) {\r\n                var tecell = teOptions.teCells [data.row.index + \":\" + data.column.dataKey];\r\n\r\n                cell.styles.halign = (atOptions.styles.halign === 'inherit') ? 'center' : atOptions.styles.halign;\r\n                cell.styles.valign = atOptions.styles.valign;\r\n\r\n                if ( typeof tecell !== 'undefined' && typeof tecell.style !== 'undefined' && tecell.style.hidden !== true ) {\r\n                  if ( atOptions.styles.halign === 'inherit' )\r\n                    cell.styles.halign = tecell.style.align;\r\n                  if ( atOptions.styles.fillColor === 'inherit' )\r\n                    cell.styles.fillColor = tecell.style.bcolor;\r\n                  if ( atOptions.styles.textColor === 'inherit' )\r\n                    cell.styles.textColor = tecell.style.color;\r\n                  if ( atOptions.styles.fontStyle === 'inherit' )\r\n                    cell.styles.fontStyle = tecell.style.fstyle;\r\n                }\r\n              };\r\n            }\r\n\r\n            if ( typeof atOptions.drawHeaderCell !== 'function' ) {\r\n              atOptions.drawHeaderCell = function (cell, data) {\r\n                var colopt = teOptions.columns [data.column.dataKey];\r\n\r\n                if ( (colopt.style.hasOwnProperty(\"hidden\") !== true || colopt.style.hidden !== true) &&\r\n                  colopt.rowIndex >= 0 )\r\n                  return prepareAutoTableText(cell, data, colopt);\r\n                else\r\n                  return false; // cell is hidden\r\n              };\r\n            }\r\n\r\n            if ( typeof atOptions.drawCell !== 'function' ) {\r\n              atOptions.drawCell = function (cell, data) {\r\n                var tecell = teOptions.teCells [data.row.index + \":\" + data.column.dataKey];\r\n                var draw2canvas = (typeof tecell !== 'undefined' &&\r\n                                   typeof tecell.elements !== 'undefined' && tecell.elements.length &&\r\n                                   tecell.elements[0].hasAttribute(\"data-tableexport-canvas\"));\r\n                if ( draw2canvas !== true ) {\r\n                  if ( prepareAutoTableText(cell, data, tecell) ) {\r\n\r\n                    teOptions.doc.rect(cell.x, cell.y, cell.width, cell.height, cell.styles.fillStyle);\r\n\r\n                    if ( typeof tecell !== 'undefined' &&\r\n                         typeof tecell.elements !== 'undefined' && tecell.elements.length ) {\r\n\r\n                      var dh = cell.height / tecell.rect.height;\r\n                      if ( dh > teOptions.dh || typeof teOptions.dh === 'undefined' )\r\n                        teOptions.dh = dh;\r\n                      teOptions.dw = cell.width / tecell.rect.width;\r\n\r\n                      var y = cell.textPos.y;\r\n                      drawAutotableElements(cell, tecell.elements, teOptions);\r\n                      cell.textPos.y = y;\r\n\r\n                      drawAutotableText(cell, tecell.elements, teOptions);\r\n                    }\r\n                    else \r\n                      drawAutotableText(cell, {}, teOptions);\r\n                  }\r\n                }\r\n                else {\r\n                  var container = tecell.elements[0];\r\n                  var imgId  = $(container).attr(\"data-tableexport-canvas\");\r\n                  jsPdfDrawImage (cell, container, imgId, teOptions);\r\n                }\r\n                return false;\r\n              };\r\n            }\r\n\r\n            // collect header and data rows\r\n            teOptions.headerrows = [];\r\n            $hrows = collectHeadRows ($(this));\r\n            $($hrows).each(function () {\r\n              colKey = 0;\r\n              teOptions.headerrows[rowIndex] = [];\r\n\r\n              ForEachVisibleCell(this, 'th,td', rowIndex, $hrows.length,\r\n                                 function (cell, row, col) {\r\n                                   var obj      = getCellStyles(cell);\r\n                                   obj.title    = parseString(cell, row, col);\r\n                                   obj.key      = colKey++;\r\n                                   obj.rowIndex = rowIndex;\r\n                                   teOptions.headerrows[rowIndex].push(obj);\r\n                                 });\r\n              rowIndex++;\r\n            });\r\n\r\n            if ( rowIndex > 0 ) {\r\n              // iterate through last row\r\n              var lastrow = rowIndex - 1;\r\n              while ( lastrow >= 0 ) {\r\n                $.each(teOptions.headerrows[lastrow], function () {\r\n                  var obj = this;\r\n\r\n                  if ( lastrow > 0 && this.rect === null )\r\n                    obj = teOptions.headerrows[lastrow - 1][this.key];\r\n\r\n                  if ( obj !== null && obj.rowIndex >= 0 &&\r\n                    (obj.style.hasOwnProperty(\"hidden\") !== true || obj.style.hidden !== true) )\r\n                    teOptions.columns.push(obj);\r\n                });\r\n\r\n                lastrow = (teOptions.columns.length > 0) ? -1 : lastrow - 1;\r\n              }\r\n            }\r\n\r\n            var rowCount = 0;\r\n            $rows        = [];\r\n            $rows = collectRows ($(this));\r\n            $($rows).each(function () {\r\n              var rowData = [];\r\n              colKey      = 0;\r\n\r\n              ForEachVisibleCell(this, 'td,th', rowIndex, $hrows.length + $rows.length,\r\n                                 function (cell, row, col) {\r\n                                   var obj;\r\n\r\n                                   if ( typeof teOptions.columns[colKey] === 'undefined' ) {\r\n                                     // jsPDF-Autotable needs columns. Thus define hidden ones for tables without thead\r\n                                     obj = {\r\n                                       title: '',\r\n                                       key:   colKey,\r\n                                       style: {\r\n                                         hidden: true\r\n                                       }\r\n                                     };\r\n                                     teOptions.columns.push(obj);\r\n                                   }\r\n                                   if ( typeof cell !== 'undefined' && cell !== null ) {\r\n                                     obj = getCellStyles(cell);\r\n                                     obj.elements = cell.hasAttribute(\"data-tableexport-canvas\") ? $(cell) : $(cell).children();\r\n                                     teOptions.teCells [rowCount + \":\" + colKey++] = obj;\r\n                                   }\r\n                                   else {\r\n                                     obj = $.extend(true, {}, teOptions.teCells [rowCount + \":\" + (colKey - 1)]);\r\n                                     obj.colspan = -1;\r\n                                     teOptions.teCells [rowCount + \":\" + colKey++] = obj;\r\n                                   }\r\n\r\n                                   rowData.push(parseString(cell, row, col));\r\n                                 });\r\n              if ( rowData.length ) {\r\n                teOptions.rows.push(rowData);\r\n                rowCount++;\r\n              }\r\n              rowIndex++;\r\n            });\r\n\r\n            // onBeforeAutotable: optional callback function before calling\r\n            // jsPDF AutoTable that can be used to modify the AutoTable options\r\n            if ( typeof teOptions.onBeforeAutotable === 'function' )\r\n              teOptions.onBeforeAutotable($(this), teOptions.columns, teOptions.rows, atOptions);\r\n\r\n            teOptions.doc.autoTable(teOptions.columns, teOptions.rows, atOptions);\r\n\r\n            // onAfterAutotable: optional callback function after returning\r\n            // from jsPDF AutoTable that can be used to modify the AutoTable options\r\n            if ( typeof teOptions.onAfterAutotable === 'function' )\r\n              teOptions.onAfterAutotable($(this), atOptions);\r\n\r\n            // set the start position for the next table (in case there is one)\r\n            defaults.jspdf.autotable.startY = teOptions.doc.autoTableEndPosY() + atOptions.margin.top;\r\n\r\n          });\r\n\r\n          jsPdfOutput(teOptions.doc, (typeof teOptions.images !== 'undefined' && jQuery.isEmptyObject(teOptions.images) === false));\r\n\r\n          if ( typeof teOptions.headerrows !== 'undefined' )\r\n            teOptions.headerrows.length = 0;\r\n          if ( typeof teOptions.columns !== 'undefined' )\r\n            teOptions.columns.length = 0;\r\n          if ( typeof teOptions.rows !== 'undefined' )\r\n            teOptions.rows.length = 0;\r\n          delete teOptions.doc;\r\n          teOptions.doc = null;\r\n        });\r\n      }\r\n    }\r\n\r\n    function collectHeadRows ($table) {\r\n      var result = [];\r\n      findTableElements($table,'thead').each(function () {\r\n        result.push.apply(result, findTableElements($(this), defaults.theadSelector).toArray());\r\n      });\r\n      return result;\r\n    }\r\n\r\n    function collectRows ($table) {\r\n      var result = [];\r\n      findTableElements($table,'tbody').each(function () {\r\n        result.push.apply(result, findTableElements($(this), defaults.tbodySelector).toArray());\r\n      });\r\n      if ( defaults.tfootSelector.length ) {\r\n        findTableElements($table,'tfoot').each(function () {\r\n          result.push.apply(result, findTableElements($(this), defaults.tfootSelector).toArray());\r\n        });\r\n      }\r\n      return result;\r\n    }\r\n\r\n    function findTableElements ($parent, selector) {\r\n      var parentSelector = $parent[0].tagName;\r\n      var parentLevel = $parent.parents(parentSelector).length;\r\n      return $parent.find(selector).filter (function () {\r\n        return parentLevel === $(this).closest(parentSelector).parents(parentSelector).length;\r\n      });\r\n    }\r\n\r\n    function GetColumnNames (table) {\r\n      var result = [];\r\n      $(table).find('thead').first().find('th').each(function (index, el) {\r\n        if ( $(el).attr(\"data-field\") !== undefined )\r\n          result[index] = $(el).attr(\"data-field\");\r\n        else\r\n          result[index] = index.toString();\r\n      });\r\n      return result;\r\n    }\r\n\r\n    function isVisible ($element) {\r\n      var isCell = typeof $element[0].cellIndex !== 'undefined';\r\n      var isRow = typeof $element[0].rowIndex !== 'undefined';\r\n      var isElementVisible = (isCell || isRow) ? isTableElementVisible($element) : $element.is(':visible');\r\n      var tableexportDisplay = $element.data(\"tableexport-display\");\r\n\r\n      if (isCell && tableexportDisplay !== 'none' && tableexportDisplay !== 'always') {\r\n        $element = $($element[0].parentNode);\r\n        isRow = typeof $element[0].rowIndex !== 'undefined';\r\n        tableexportDisplay = $element.data(\"tableexport-display\");\r\n      }\r\n      if (isRow && tableexportDisplay !== 'none' && tableexportDisplay !== 'always') {\r\n        tableexportDisplay = $element.closest('table').data(\"tableexport-display\");\r\n      }\r\n\r\n      return tableexportDisplay !== 'none' && (isElementVisible === true || tableexportDisplay === 'always');\r\n    }\r\n\r\n    function isTableElementVisible ($element) {\r\n      var hiddenEls = [];\r\n\r\n      if ( checkCellVisibilty ) {\r\n        hiddenEls = $hiddenTableElements.filter (function () {\r\n          var found = false;\r\n\r\n          if (this.nodeType === $element[0].nodeType) {\r\n            if (typeof this.rowIndex !== 'undefined' && this.rowIndex === $element[0].rowIndex)\r\n              found = true;\r\n            else if (typeof this.cellIndex !== 'undefined' && this.cellIndex === $element[0].cellIndex &&\r\n              typeof this.parentNode.rowIndex !== 'undefined' &&\r\n              typeof $element[0].parentNode.rowIndex !== 'undefined' &&\r\n              this.parentNode.rowIndex === $element[0].parentNode.rowIndex)\r\n              found = true;\r\n          }\r\n          return found;\r\n        });\r\n      }\r\n      return (checkCellVisibilty === false || hiddenEls.length === 0);\r\n    }\r\n\r\n    function isColumnIgnored ($cell, rowLength, colIndex) {\r\n      var result = false;\r\n\r\n      if (isVisible($cell)) {\r\n        if ( defaults.ignoreColumn.length > 0 ) {\r\n          if ( $.inArray(colIndex, defaults.ignoreColumn) !== -1 ||\r\n            $.inArray(colIndex - rowLength, defaults.ignoreColumn) !== -1 ||\r\n            (colNames.length > colIndex && typeof colNames[colIndex] !== 'undefined' &&\r\n              $.inArray(colNames[colIndex], defaults.ignoreColumn) !== -1) )\r\n            result = true;\r\n        }\r\n      }\r\n      else\r\n        result = true;\r\n\r\n      return result;\r\n    }\r\n\r\n    function ForEachVisibleCell (tableRow, selector, rowIndex, rowCount, cellcallback) {\r\n      if ( typeof (cellcallback) === 'function' ) {\r\n        var ignoreRow = false;\r\n\r\n        if (typeof defaults.onIgnoreRow === 'function')\r\n          ignoreRow = defaults.onIgnoreRow($(tableRow), rowIndex);\r\n\r\n        if (ignoreRow === false &&\r\n          $.inArray(rowIndex, defaults.ignoreRow) === -1 &&\r\n          $.inArray(rowIndex - rowCount, defaults.ignoreRow) === -1 &&\r\n          isVisible($(tableRow))) {\r\n\r\n          var $cells = findTableElements($(tableRow), selector);\r\n          var cellCount = 0;\r\n\r\n          $cells.each(function (colIndex) {\r\n            var $cell = $(this);\r\n            var c;\r\n            var colspan = getColspan (this);\r\n            var rowspan = getRowspan (this);\r\n\r\n            // Skip ranges\r\n            $.each(ranges, function () {\r\n              var range = this;\r\n              if ( rowIndex >= range.s.r && rowIndex <= range.e.r && cellCount >= range.s.c && cellCount <= range.e.c ) {\r\n                for ( c = 0; c <= range.e.c - range.s.c; ++c )\r\n                  cellcallback(null, rowIndex, cellCount++);\r\n              }\r\n            });\r\n\r\n            if ( isColumnIgnored($cell, $cells.length, colIndex) === false ) {\r\n              // Handle Row Span\r\n              if ( rowspan || colspan ) {\r\n                rowspan = rowspan || 1;\r\n                colspan = colspan || 1;\r\n                ranges.push({\r\n                              s: {r: rowIndex, c: cellCount},\r\n                              e: {r: rowIndex + rowspan - 1, c: cellCount + colspan - 1}\r\n                            });\r\n              }\r\n\r\n              // Handle Value\r\n              cellcallback(this, rowIndex, cellCount++);\r\n            }\r\n\r\n            // Handle Colspan\r\n            if ( colspan )\r\n              for ( c = 0; c < colspan - 1; ++c )\r\n                cellcallback(null, rowIndex, cellCount++);\r\n          });\r\n\r\n          // Skip ranges\r\n          $.each(ranges, function () {\r\n            var range = this;\r\n            if ( rowIndex >= range.s.r && rowIndex <= range.e.r && cellCount >= range.s.c && cellCount <= range.e.c ) {\r\n              for ( c = 0; c <= range.e.c - range.s.c; ++c )\r\n                cellcallback(null, rowIndex, cellCount++);\r\n            }\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    function jsPdfDrawImage (cell, container, imgId, teOptions) {\r\n      if ( typeof teOptions.images !== 'undefined' ) {\r\n        var image = teOptions.images[imgId];\r\n\r\n        if ( typeof image !== 'undefined' ) {\r\n          var arCell    = cell.width / cell.height;\r\n          var arImg     = container.width / container.height;\r\n          var imgWidth  = cell.width;\r\n          var imgHeight = cell.height;\r\n          var px2pt     = 0.264583 * 72 / 25.4;\r\n          var uy        = 0;\r\n\r\n          if ( arImg <= arCell ) {\r\n            imgHeight = Math.min(cell.height, container.height);\r\n            imgWidth  = container.width * imgHeight / container.height;\r\n          }\r\n          else if ( arImg > arCell ) {\r\n            imgWidth  = Math.min(cell.width, container.width);\r\n            imgHeight = container.height * imgWidth / container.width;\r\n          }\r\n\r\n          imgWidth *= px2pt;\r\n          imgHeight *= px2pt;\r\n\r\n          if ( imgHeight < cell.height )\r\n            uy = (cell.height - imgHeight) / 2;\r\n\r\n          try {\r\n            teOptions.doc.addImage(image.src, cell.textPos.x, cell.y + uy, imgWidth, imgHeight);\r\n          }\r\n          catch (e) {\r\n            // TODO: IE -> convert png to jpeg\r\n          }\r\n          cell.textPos.x += imgWidth;\r\n        }\r\n      }\r\n    }\r\n\r\n    function jsPdfOutput (doc, hasimages) {\r\n      if ( defaults.outputMode === 'string' )\r\n        return doc.output();\r\n\r\n      if ( defaults.outputMode === 'base64' )\r\n        return base64encode(doc.output());\r\n\r\n      if ( defaults.outputMode === 'window' ) {\r\n        window.URL = window.URL || window.webkitURL;\r\n        window.open(window.URL.createObjectURL(doc.output(\"blob\")));\r\n        return;\r\n      }\r\n\r\n      try {\r\n        var blob = doc.output('blob');\r\n        saveAs(blob, defaults.fileName + '.pdf');\r\n      }\r\n      catch (e) {\r\n        downloadFile(defaults.fileName + '.pdf',\r\n          'data:application/pdf' + (hasimages ? '' : ';base64') + ',',\r\n          hasimages ? doc.output('blob') : doc.output());\r\n      }\r\n    }\r\n\r\n    function prepareAutoTableText (cell, data, cellopt) {\r\n      var cs = 0;\r\n      if ( typeof cellopt !== 'undefined' )\r\n        cs = cellopt.colspan;\r\n\r\n      if ( cs >= 0 ) {\r\n        // colspan handling\r\n        var cellWidth = cell.width;\r\n        var textPosX  = cell.textPos.x;\r\n        var i         = data.table.columns.indexOf(data.column);\r\n\r\n        for ( var c = 1; c < cs; c++ ) {\r\n          var column = data.table.columns[i + c];\r\n          cellWidth += column.width;\r\n        }\r\n\r\n        if ( cs > 1 ) {\r\n          if ( cell.styles.halign === 'right' )\r\n            textPosX = cell.textPos.x + cellWidth - cell.width;\r\n          else if ( cell.styles.halign === 'center' )\r\n            textPosX = cell.textPos.x + (cellWidth - cell.width) / 2;\r\n        }\r\n\r\n        cell.width     = cellWidth;\r\n        cell.textPos.x = textPosX;\r\n\r\n        if ( typeof cellopt !== 'undefined' && cellopt.rowspan > 1 )\r\n          cell.height = cell.height * cellopt.rowspan;\r\n\r\n        // fix jsPDF's calculation of text position\r\n        if ( cell.styles.valign === 'middle' || cell.styles.valign === 'bottom' ) {\r\n          var splittedText = typeof cell.text === 'string' ? cell.text.split(/\\r\\n|\\r|\\n/g) : cell.text;\r\n          var lineCount    = splittedText.length || 1;\r\n          if ( lineCount > 2 )\r\n            cell.textPos.y -= ((2 - FONT_ROW_RATIO) / 2 * data.row.styles.fontSize) * (lineCount - 2) / 3;\r\n        }\r\n        return true;\r\n      }\r\n      else\r\n        return false; // cell is hidden (colspan = -1), don't draw it\r\n    }\r\n\r\n    function collectImages (cell, elements, teOptions) {\r\n      if ( typeof cell !== 'undefined' && cell !== null ) {\r\n\r\n        if ( cell.hasAttribute(\"data-tableexport-canvas\") ) {\r\n          var imgId = new Date().getTime();\r\n          $(cell).attr(\"data-tableexport-canvas\", imgId);\r\n\r\n          teOptions.images[imgId] = {\r\n            url: '[data-tableexport-canvas=\"'+imgId+'\"]',\r\n            src: null\r\n          };\r\n        }\r\n        else if (elements !== 'undefined' && elements != null) {\r\n          elements.each(function () {\r\n            if ($(this).is(\"img\")) {\r\n              var imgId = strHashCode(this.src);\r\n              teOptions.images[imgId] = {\r\n                url: this.src,\r\n                src: this.src\r\n              };\r\n            }\r\n            collectImages(cell, $(this).children(), teOptions);\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    function loadImages (teOptions, callback) {\r\n      var imageCount = 0;\r\n      var pendingCount = 0;\r\n\r\n      function done () {\r\n        callback(imageCount);\r\n      }\r\n\r\n      function loadImage (image) {\r\n        if (image.url) {\r\n          if (!image.src) {\r\n            var $imgContainer = $(image.url);\r\n            if ($imgContainer.length) {\r\n              imageCount = ++pendingCount;\r\n\r\n              html2canvas($imgContainer[0]).then(function(canvas) {\r\n                image.src = canvas.toDataURL(\"image/png\");\r\n                if ( !--pendingCount )\r\n                  done();\r\n              });\r\n            }\r\n          }\r\n          else {\r\n            var img = new Image();\r\n            imageCount = ++pendingCount;\r\n            img.crossOrigin = 'Anonymous';\r\n            img.onerror = img.onload = function () {\r\n              if ( img.complete ) {\r\n\r\n                if ( img.src.indexOf('data:image/') === 0 ) {\r\n                  img.width = image.width || img.width || 0;\r\n                  img.height = image.height || img.height || 0;\r\n                }\r\n\r\n                if ( img.width + img.height ) {\r\n                  var canvas = document.createElement(\"canvas\");\r\n                  var ctx = canvas.getContext(\"2d\");\r\n\r\n                  canvas.width = img.width;\r\n                  canvas.height = img.height;\r\n                  ctx.drawImage(img, 0, 0);\r\n\r\n                  image.src = canvas.toDataURL(\"image/png\");\r\n                }\r\n              }\r\n              if ( !--pendingCount )\r\n                done();\r\n            };\r\n            img.src = image.url;\r\n          }\r\n        }\r\n      }\r\n\r\n      if ( typeof teOptions.images !== 'undefined' ) {\r\n        for ( var i in teOptions.images )\r\n          if ( teOptions.images.hasOwnProperty(i) )\r\n            loadImage(teOptions.images[i]);\r\n      }\r\n\r\n      return pendingCount || done();\r\n    }\r\n\r\n    function drawAutotableElements (cell, elements, teOptions) {\r\n      elements.each(function () {\r\n        if ( $(this).is(\"div\") ) {\r\n          var bcolor = rgb2array(getStyle(this, 'background-color'), [255, 255, 255]);\r\n          var lcolor = rgb2array(getStyle(this, 'border-top-color'), [0, 0, 0]);\r\n          var lwidth = getPropertyUnitValue(this, 'border-top-width', defaults.jspdf.unit);\r\n\r\n          var r  = this.getBoundingClientRect();\r\n          var ux = this.offsetLeft * teOptions.dw;\r\n          var uy = this.offsetTop * teOptions.dh;\r\n          var uw = r.width * teOptions.dw;\r\n          var uh = r.height * teOptions.dh;\r\n\r\n          teOptions.doc.setDrawColor.apply(undefined, lcolor);\r\n          teOptions.doc.setFillColor.apply(undefined, bcolor);\r\n          teOptions.doc.setLineWidth(lwidth);\r\n          teOptions.doc.rect(cell.x + ux, cell.y + uy, uw, uh, lwidth ? \"FD\" : \"F\");\r\n        }\r\n        else if ( $(this).is(\"img\") ) {\r\n          var imgId  = strHashCode(this.src);\r\n          jsPdfDrawImage (cell, this, imgId, teOptions);\r\n        }\r\n\r\n        drawAutotableElements(cell, $(this).children(), teOptions);\r\n      });\r\n    }\r\n\r\n    function drawAutotableText (cell, texttags, teOptions) {\r\n      if ( typeof teOptions.onAutotableText === 'function' ) {\r\n        teOptions.onAutotableText(teOptions.doc, cell, texttags);\r\n      }\r\n      else {\r\n        var x     = cell.textPos.x;\r\n        var y     = cell.textPos.y;\r\n        var style = {halign: cell.styles.halign, valign: cell.styles.valign};\r\n\r\n        if ( texttags.length ) {\r\n          var tag = texttags[0];\r\n          while ( tag.previousSibling )\r\n            tag = tag.previousSibling;\r\n\r\n          var b = false, i = false;\r\n\r\n          while ( tag ) {\r\n            var txt = tag.innerText || tag.textContent || \"\";\r\n            var leadingspace = (txt.length && txt[0] === \" \") ? \" \" : \"\";\r\n            var trailingspace = (txt.length > 1 && txt[txt.length - 1] === \" \") ? \" \" : \"\";\r\n\r\n            if (defaults.preserve.leadingWS !== true)\r\n              txt = leadingspace + trimLeft(txt);\r\n            if (defaults.preserve.trailingWS !== true)\r\n              txt = trimRight(txt) + trailingspace;\r\n\r\n            if ( $(tag).is(\"br\") ) {\r\n              x = cell.textPos.x;\r\n              y += teOptions.doc.internal.getFontSize();\r\n            }\r\n\r\n            if ( $(tag).is(\"b\") )\r\n              b = true;\r\n            else if ( $(tag).is(\"i\") )\r\n              i = true;\r\n\r\n            if ( b || i )\r\n              teOptions.doc.setFontType((b && i) ? \"bolditalic\" : b ? \"bold\" : \"italic\");\r\n\r\n            var w = teOptions.doc.getStringUnitWidth(txt) * teOptions.doc.internal.getFontSize();\r\n\r\n            if ( w ) {\r\n              if ( cell.styles.overflow === 'linebreak' &&\r\n                   x > cell.textPos.x && (x + w) > (cell.textPos.x + cell.width) ) {\r\n                var chars = \".,!%*;:=-\";\r\n                if ( chars.indexOf(txt.charAt(0)) >= 0 ) {\r\n                  var s = txt.charAt(0);\r\n                  w     = teOptions.doc.getStringUnitWidth(s) * teOptions.doc.internal.getFontSize();\r\n                  if ( (x + w) <= (cell.textPos.x + cell.width) ) {\r\n                    teOptions.doc.autoTableText(s, x, y, style);\r\n                    txt = txt.substring(1, txt.length);\r\n                  }\r\n                  w = teOptions.doc.getStringUnitWidth(txt) * teOptions.doc.internal.getFontSize();\r\n                }\r\n                x = cell.textPos.x;\r\n                y += teOptions.doc.internal.getFontSize();\r\n              }\r\n\r\n              if ( cell.styles.overflow !== 'visible' ) {\r\n                while ( txt.length && (x + w) > (cell.textPos.x + cell.width) ) {\r\n                  txt = txt.substring(0, txt.length - 1);\r\n                  w   = teOptions.doc.getStringUnitWidth(txt) * teOptions.doc.internal.getFontSize();\r\n                }\r\n              }\r\n\r\n              teOptions.doc.autoTableText(txt, x, y, style);\r\n              x += w;\r\n            }\r\n\r\n            if ( b || i ) {\r\n              if ( $(tag).is(\"b\") )\r\n                b = false;\r\n              else if ( $(tag).is(\"i\") )\r\n                i = false;\r\n\r\n              teOptions.doc.setFontType((!b && !i) ? \"normal\" : b ? \"bold\" : \"italic\");\r\n            }\r\n\r\n            tag = tag.nextSibling;\r\n          }\r\n          cell.textPos.x = x;\r\n          cell.textPos.y = y;\r\n        }\r\n        else {\r\n          teOptions.doc.autoTableText(cell.text, cell.textPos.x, cell.textPos.y, style);\r\n        }\r\n      }\r\n    }\r\n\r\n    function escapeRegExp (string) {\r\n      return string == null ? \"\" : string.toString().replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\");\r\n    }\r\n\r\n    function replaceAll (string, find, replace) {\r\n      return string == null ? \"\" : string.toString().replace(new RegExp(escapeRegExp(find), 'g'), replace);\r\n    }\r\n\r\n    function trimLeft (string) {\r\n      return string == null ? \"\" : string.toString().replace(/^\\s+/, \"\");\r\n    }\r\n\r\n    function trimRight (string) {\r\n      return string == null ? \"\" : string.toString().replace(/\\s+$/, \"\");\r\n    }\r\n\r\n    function parseNumber (value) {\r\n      value = value || \"0\";\r\n      value = replaceAll(value, defaults.numbers.html.thousandsSeparator, '');\r\n      value = replaceAll(value, defaults.numbers.html.decimalMark, '.');\r\n\r\n      return typeof value === \"number\" || jQuery.isNumeric(value) !== false ? value : false;\r\n    }\r\n\r\n    function parsePercent (value) {\r\n      if ( value.indexOf(\"%\") > -1 ) {\r\n        value = parseNumber(value.replace(/%/g, \"\"));\r\n        if ( value !== false )\r\n          value = value / 100;\r\n      }\r\n      else\r\n        value = false;\r\n      return value;\r\n    }\r\n\r\n    function parseString (cell, rowIndex, colIndex) {\r\n      var result = '';\r\n\r\n      if ( cell !== null ) {\r\n        var $cell = $(cell);\r\n        var htmlData;\r\n\r\n        if ( $cell[0].hasAttribute(\"data-tableexport-canvas\") ) {\r\n          htmlData = '';\r\n        }\r\n        else if ( $cell[0].hasAttribute(\"data-tableexport-value\") ) {\r\n          htmlData = $cell.data(\"tableexport-value\");\r\n          htmlData = htmlData ? htmlData + '' : '';\r\n        }\r\n        else {\r\n          htmlData = $cell.html();\r\n\r\n          if ( typeof defaults.onCellHtmlData === 'function' )\r\n            htmlData = defaults.onCellHtmlData($cell, rowIndex, colIndex, htmlData);\r\n          else if ( htmlData !== '' ) {\r\n            var html      = $.parseHTML(htmlData);\r\n            var inputidx  = 0;\r\n            var selectidx = 0;\r\n\r\n            htmlData = '';\r\n            $.each(html, function () {\r\n              if ( $(this).is(\"input\") )\r\n                htmlData += $cell.find('input').eq(inputidx++).val();\r\n              else if ( $(this).is(\"select\") )\r\n                htmlData += $cell.find('select option:selected').eq(selectidx++).text();\r\n              else if ( $(this).is(\"br\") )\r\n                htmlData += \"<br>\";\r\n              else {\r\n                if ( typeof $(this).html() === 'undefined' )\r\n                  htmlData += $(this).text();\r\n                else if ( jQuery().bootstrapTable === undefined ||\r\n                  ($(this).hasClass('filterControl') !== true &&\r\n                    $(cell).parents('.detail-view').length === 0) )\r\n                  htmlData += $(this).html();\r\n              }\r\n            });\r\n          }\r\n        }\r\n\r\n        if ( defaults.htmlContent === true ) {\r\n          result = $.trim(htmlData);\r\n        }\r\n        else if ( htmlData && htmlData !== '' ) {\r\n          var cellFormat = $(cell).data(\"tableexport-cellformat\");\r\n\r\n          if ( cellFormat !== '' ) {\r\n            var text   = htmlData.replace(/\\n/g, '\\u2028').replace(/(<\\s*br([^>]*)>)/gi, '\\u2060');\r\n            var obj    = $('<div/>').html(text).contents();\r\n            var number = false;\r\n            text       = '';\r\n\r\n            $.each(obj.text().split(\"\\u2028\"), function (i, v) {\r\n              if ( i > 0 )\r\n                text += \" \";\r\n\r\n              if (defaults.preserve.leadingWS !== true)\r\n                v = trimLeft(v);\r\n              text += (defaults.preserve.trailingWS !== true) ? trimRight(v) : v;\r\n            });\r\n\r\n            $.each(text.split(\"\\u2060\"), function (i, v) {\r\n              if ( i > 0 )\r\n                result += \"\\n\";\r\n\r\n              if (defaults.preserve.leadingWS !== true)\r\n                v = trimLeft(v);\r\n              if (defaults.preserve.trailingWS !== true)\r\n                v = trimRight(v);\r\n              result += v.replace(/\\u00AD/g, \"\"); // remove soft hyphens\r\n            });\r\n\r\n            result = result.replace(/\\u00A0/g, \" \"); // replace nbsp's with spaces\r\n\r\n            if ( defaults.type === 'json' ||\r\n              (defaults.type === 'excel' && defaults.mso.fileFormat === 'xmlss') ||\r\n              defaults.numbers.output === false ) {\r\n              number = parseNumber(result);\r\n\r\n              if ( number !== false )\r\n                result = Number(number);\r\n            }\r\n            else if ( defaults.numbers.html.decimalMark !== defaults.numbers.output.decimalMark ||\r\n              defaults.numbers.html.thousandsSeparator !== defaults.numbers.output.thousandsSeparator ) {\r\n              number = parseNumber(result);\r\n\r\n              if ( number !== false ) {\r\n                var frac = (\"\" + number.substr(number < 0 ? 1 : 0)).split('.');\r\n                if ( frac.length === 1 )\r\n                  frac[1] = \"\";\r\n                var mod = frac[0].length > 3 ? frac[0].length % 3 : 0;\r\n\r\n                result = (number < 0 ? \"-\" : \"\") +\r\n                  (defaults.numbers.output.thousandsSeparator ? ((mod ? frac[0].substr(0, mod) + defaults.numbers.output.thousandsSeparator : \"\") + frac[0].substr(mod).replace(/(\\d{3})(?=\\d)/g, \"$1\" + defaults.numbers.output.thousandsSeparator)) : frac[0]) +\r\n                  (frac[1].length ? defaults.numbers.output.decimalMark + frac[1] : \"\");\r\n              }\r\n            }\r\n          }\r\n          else\r\n            result = htmlData;\r\n        }\r\n\r\n        if ( defaults.escape === true ) {\r\n          //noinspection JSDeprecatedSymbols\r\n          result = escape(result);\r\n        }\r\n\r\n        if ( typeof defaults.onCellData === 'function' ) {\r\n          result = defaults.onCellData($cell, rowIndex, colIndex, result);\r\n        }\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n    function preventInjection (string) {\r\n      if ( string.length > 0 && defaults.preventInjection === true ) {\r\n        var chars = \"=+-@\";\r\n        if ( chars.indexOf(string.charAt(0)) >= 0 )\r\n          return ( \"'\" + string );\r\n      }\r\n      return string;\r\n    }\r\n\r\n    //noinspection JSUnusedLocalSymbols\r\n    function hyphenate (a, b, c) {\r\n      return b + \"-\" + c.toLowerCase();\r\n    }\r\n\r\n    function rgb2array (rgb_string, default_result) {\r\n      var re     = /^rgb\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})\\)$/;\r\n      var bits   = re.exec(rgb_string);\r\n      var result = default_result;\r\n      if ( bits )\r\n        result = [parseInt(bits[1]), parseInt(bits[2]), parseInt(bits[3])];\r\n      return result;\r\n    }\r\n\r\n    function getCellStyles (cell) {\r\n      var a  = getStyle(cell, 'text-align');\r\n      var fw = getStyle(cell, 'font-weight');\r\n      var fs = getStyle(cell, 'font-style');\r\n      var f  = '';\r\n      if ( a === 'start' )\r\n        a = getStyle(cell, 'direction') === 'rtl' ? 'right' : 'left';\r\n      if ( fw >= 700 )\r\n        f = 'bold';\r\n      if ( fs === 'italic' )\r\n        f += fs;\r\n      if ( f === '' )\r\n        f = 'normal';\r\n\r\n      var result = {\r\n        style:   {\r\n          align:  a,\r\n          bcolor: rgb2array(getStyle(cell, 'background-color'), [255, 255, 255]),\r\n          color:  rgb2array(getStyle(cell, 'color'), [0, 0, 0]),\r\n          fstyle: f\r\n        },\r\n        colspan: getColspan (cell),\r\n        rowspan: getRowspan (cell)\r\n      };\r\n\r\n      if ( cell !== null ) {\r\n        var r       = cell.getBoundingClientRect();\r\n        result.rect = {\r\n          width:  r.width,\r\n          height: r.height\r\n        };\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n    function getColspan (cell) {\r\n      var result = $(cell).data(\"tableexport-colspan\");\r\n      if ( typeof result === 'undefined' && $(cell).is(\"[colspan]\") )\r\n        result = $(cell).attr('colspan');\r\n\r\n      return (parseInt(result) || 0);\r\n    }\r\n\r\n    function getRowspan (cell) {\r\n      var result = $(cell).data(\"tableexport-rowspan\");\r\n      if ( typeof result === 'undefined' && $(cell).is(\"[rowspan]\") )\r\n        result = $(cell).attr('rowspan');\r\n\r\n      return (parseInt(result) || 0);\r\n    }\r\n\r\n    // get computed style property\r\n    function getStyle (target, prop) {\r\n      try {\r\n        if ( window.getComputedStyle ) { // gecko and webkit\r\n          prop = prop.replace(/([a-z])([A-Z])/, hyphenate);  // requires hyphenated, not camel\r\n          return window.getComputedStyle(target, null).getPropertyValue(prop);\r\n        }\r\n        if ( target.currentStyle ) { // ie\r\n          return target.currentStyle[prop];\r\n        }\r\n        return target.style[prop];\r\n      }\r\n      catch (e) {\r\n      }\r\n      return \"\";\r\n    }\r\n\r\n    function getUnitValue (parent, value, unit) {\r\n      var baseline = 100;  // any number serves\r\n\r\n      var temp              = document.createElement(\"div\");  // create temporary element\r\n      temp.style.overflow   = \"hidden\";  // in case baseline is set too low\r\n      temp.style.visibility = \"hidden\";  // no need to show it\r\n\r\n      parent.appendChild(temp); // insert it into the parent for em, ex and %\r\n\r\n      temp.style.width = baseline + unit;\r\n      var factor       = baseline / temp.offsetWidth;\r\n\r\n      parent.removeChild(temp);  // clean up\r\n\r\n      return (value * factor);\r\n    }\r\n\r\n    function getPropertyUnitValue (target, prop, unit) {\r\n      var value = getStyle(target, prop);  // get the computed style value\r\n\r\n      var numeric = value.match(/\\d+/);  // get the numeric component\r\n      if ( numeric !== null ) {\r\n        numeric = numeric[0];  // get the string\r\n\r\n        return getUnitValue(target.parentElement, numeric, unit);\r\n      }\r\n      return 0;\r\n    }\r\n\r\n    function jx_Workbook () {\r\n      if ( !(this instanceof jx_Workbook) ) {\r\n        //noinspection JSPotentiallyInvalidConstructorUsage\r\n        return new jx_Workbook();\r\n      }\r\n      this.SheetNames = [];\r\n      this.Sheets     = {};\r\n    }\r\n\r\n    function jx_s2ab (s) {\r\n      var buf  = new ArrayBuffer(s.length);\r\n      var view = new Uint8Array(buf);\r\n      for ( var i = 0; i !== s.length; ++i ) view[i] = s.charCodeAt(i) & 0xFF;\r\n      return buf;\r\n    }\r\n\r\n    function jx_datenum (v, date1904) {\r\n      if ( date1904 ) v += 1462;\r\n      var epoch = Date.parse(v);\r\n      return (epoch - new Date(Date.UTC(1899, 11, 30))) / (24 * 60 * 60 * 1000);\r\n    }\r\n\r\n    function jx_createSheet (data) {\r\n      var ws    = {};\r\n      var range = {s: {c: 10000000, r: 10000000}, e: {c: 0, r: 0}};\r\n      for ( var R = 0; R !== data.length; ++R ) {\r\n        for ( var C = 0; C !== data[R].length; ++C ) {\r\n          if ( range.s.r > R ) range.s.r = R;\r\n          if ( range.s.c > C ) range.s.c = C;\r\n          if ( range.e.r < R ) range.e.r = R;\r\n          if ( range.e.c < C ) range.e.c = C;\r\n          var cell = {v: data[R][C]};\r\n          if ( cell.v === null ) continue;\r\n          var cell_ref = XLSX.utils.encode_cell({c: C, r: R});\r\n\r\n          if ( typeof cell.v === 'number' ) cell.t = 'n';\r\n          else if ( typeof cell.v === 'boolean' ) cell.t = 'b';\r\n          else if ( cell.v instanceof Date ) {\r\n            cell.t = 'n';\r\n            cell.z = XLSX.SSF._table[14];\r\n            cell.v = jx_datenum(cell.v);\r\n          }\r\n          else cell.t = 's';\r\n          ws[cell_ref] = cell;\r\n        }\r\n      }\r\n\r\n      if ( range.s.c < 10000000 ) ws['!ref'] = XLSX.utils.encode_range(range);\r\n      return ws;\r\n    }\r\n\r\n    function strHashCode (str) {\r\n      var hash = 0, i, chr, len;\r\n      if ( str.length === 0 ) return hash;\r\n      for ( i = 0, len = str.length; i < len; i++ ) {\r\n        chr  = str.charCodeAt(i);\r\n        hash = ((hash << 5) - hash) + chr;\r\n        hash |= 0; // Convert to 32bit integer\r\n      }\r\n      return hash;\r\n    }\r\n\r\n    function downloadFile (filename, header, data) {\r\n      var ua = window.navigator.userAgent;\r\n      if ( filename !== false && window.navigator.msSaveOrOpenBlob ) {\r\n        //noinspection JSUnresolvedFunction\r\n        window.navigator.msSaveOrOpenBlob(new Blob([data]), filename);\r\n      }\r\n      else if ( filename !== false && (ua.indexOf(\"MSIE \") > 0 || !!ua.match(/Trident.*rv\\:11\\./)) ) {\r\n        // Internet Explorer (<= 9) workaround by Darryl (https://github.com/dawiong/tableExport.jquery.plugin)\r\n        // based on sampopes answer on http://stackoverflow.com/questions/22317951\r\n        // ! Not working for json and pdf format !\r\n        var frame = document.createElement(\"iframe\");\r\n\r\n        if ( frame ) {\r\n          document.body.appendChild(frame);\r\n          frame.setAttribute(\"style\", \"display:none\");\r\n          frame.contentDocument.open(\"txt/plain\", \"replace\");\r\n          frame.contentDocument.write(data);\r\n          frame.contentDocument.close();\r\n          frame.contentDocument.focus();\r\n\r\n          var extension = filename.substr((filename.lastIndexOf('.') +1));\r\n          switch(extension) {\r\n            case 'doc': case 'json': case 'png': case 'pdf': case 'xls': case 'xlsx':\r\n            filename += \".txt\";\r\n            break;\r\n          }\r\n          frame.contentDocument.execCommand(\"SaveAs\", true, filename);\r\n          document.body.removeChild(frame);\r\n        }\r\n      }\r\n      else {\r\n        var DownloadLink = document.createElement('a');\r\n\r\n        if ( DownloadLink ) {\r\n          var blobUrl = null;\r\n\r\n          DownloadLink.style.display = 'none';\r\n          if ( filename !== false )\r\n            DownloadLink.download = filename;\r\n          else\r\n            DownloadLink.target = '_blank';\r\n\r\n          if ( typeof data === 'object' ) {\r\n            window.URL = window.URL || window.webkitURL;\r\n            var binaryData = [];\r\n            binaryData.push(data);\r\n            blobUrl = window.URL.createObjectURL(new Blob(binaryData, {type: header}));\r\n            DownloadLink.href = blobUrl;\r\n          }\r\n          else if ( header.toLowerCase().indexOf(\"base64,\") >= 0 )\r\n            DownloadLink.href = header + base64encode(data);\r\n          else\r\n            DownloadLink.href = header + encodeURIComponent(data);\r\n\r\n          document.body.appendChild(DownloadLink);\r\n\r\n          if ( document.createEvent ) {\r\n            if ( DownloadEvt === null )\r\n              DownloadEvt = document.createEvent('MouseEvents');\r\n\r\n            DownloadEvt.initEvent('click', true, false);\r\n            DownloadLink.dispatchEvent(DownloadEvt);\r\n          }\r\n          else if ( document.createEventObject )\r\n            DownloadLink.fireEvent('onclick');\r\n          else if ( typeof DownloadLink.onclick === 'function' )\r\n            DownloadLink.onclick();\r\n\r\n          setTimeout(function(){\r\n            if ( blobUrl )\r\n              window.URL.revokeObjectURL(blobUrl);\r\n            document.body.removeChild(DownloadLink);\r\n          }, 100);\r\n        }\r\n      }\r\n    }\r\n\r\n    function utf8Encode (text) {\r\n      if (typeof text === 'string') {\r\n        text = text.replace(/\\x0d\\x0a/g, \"\\x0a\");\r\n        var utftext = \"\";\r\n        for ( var n = 0; n < text.length; n++ ) {\r\n          var c = text.charCodeAt(n);\r\n          if ( c < 128 ) {\r\n            utftext += String.fromCharCode(c);\r\n          }\r\n          else if ( (c > 127) && (c < 2048) ) {\r\n            utftext += String.fromCharCode((c >> 6) | 192);\r\n            utftext += String.fromCharCode((c & 63) | 128);\r\n          }\r\n          else {\r\n            utftext += String.fromCharCode((c >> 12) | 224);\r\n            utftext += String.fromCharCode(((c >> 6) & 63) | 128);\r\n            utftext += String.fromCharCode((c & 63) | 128);\r\n          }\r\n        }\r\n        return utftext;\r\n      }\r\n      return text;\r\n    }\r\n\r\n    function base64encode (input) {\r\n      var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\r\n      var keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\r\n      var output = \"\";\r\n      var i      = 0;\r\n      input      = utf8Encode(input);\r\n      while ( i < input.length ) {\r\n        chr1 = input.charCodeAt(i++);\r\n        chr2 = input.charCodeAt(i++);\r\n        chr3 = input.charCodeAt(i++);\r\n        enc1 = chr1 >> 2;\r\n        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\r\n        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\r\n        enc4 = chr3 & 63;\r\n        if ( isNaN(chr2) ) {\r\n          enc3 = enc4 = 64;\r\n        } else if ( isNaN(chr3) ) {\r\n          enc4 = 64;\r\n        }\r\n        output = output +\r\n          keyStr.charAt(enc1) + keyStr.charAt(enc2) +\r\n          keyStr.charAt(enc3) + keyStr.charAt(enc4);\r\n      }\r\n      return output;\r\n    }\r\n\r\n    return this;\r\n  }\r\n})(jQuery);\r\n\n\n//# sourceURL=webpack:///./node_modules/tableexport.jquery.plugin/tableExport.js?");

/***/ })

/******/ });
});;